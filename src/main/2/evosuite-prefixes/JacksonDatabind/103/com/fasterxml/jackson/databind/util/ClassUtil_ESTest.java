/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 23:57:27 GMT 2024
 */
package com.fasterxml.jackson.databind.util;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.util.BufferRecycler;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import com.fasterxml.jackson.core.util.JsonGeneratorDelegate;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.fasterxml.jackson.databind.annotation.NoClass;
import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;
import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;
import com.fasterxml.jackson.databind.node.TextNode;
import com.fasterxml.jackson.databind.type.ArrayType;
import com.fasterxml.jackson.databind.type.MapType;
import com.fasterxml.jackson.databind.type.PlaceholderForType;
import com.fasterxml.jackson.databind.type.ReferenceType;
import com.fasterxml.jackson.databind.type.ResolvedRecursiveType;
import com.fasterxml.jackson.databind.type.SimpleType;
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.util.AccessPattern;
import com.fasterxml.jackson.databind.util.ClassUtil;
import com.fasterxml.jackson.databind.util.Named;
import java.io.CharArrayWriter;
import java.io.Closeable;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.lang.annotation.Annotation;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Constructor;
import java.lang.reflect.Member;
import java.math.BigDecimal;
import java.sql.ClientInfoStatus;
import java.sql.SQLClientInfoException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLNonTransientException;
import java.sql.SQLRecoverableException;
import java.sql.SQLTimeoutException;
import java.sql.SQLTransactionRollbackException;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockIOException;
import org.evosuite.runtime.mock.java.lang.MockError;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class ClassUtil_ESTest extends ClassUtil_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        EnumSet<AccessPattern> enumSet0 = EnumSet.noneOf(class0);
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(enumSet0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Class<Void> class0 = Void.class;
        Constructor<Void> constructor0 = ClassUtil.findConstructor(class0, true);
    }

    @Test(timeout = 4000)
    public void test0012() throws Throwable {
        Class<Void> class0 = Void.class;
        Constructor<Void> constructor0 = ClassUtil.findConstructor(class0, true);
        ClassUtil.checkAndFixAccess((Member) constructor0);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test0023() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        ClassUtil.findConstructor(class0, false);
    }

    @Test(timeout = 4000)
    public void test0034() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        Class<JsonMappingException> class0 = JsonMappingException.class;
        ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    }

    @Test(timeout = 4000)
    public void test0045() throws Throwable {
        SQLClientInfoException sQLClientInfoException0 = new SQLClientInfoException("Me|<[@o.O]r,Iz", (Map<String, ClientInfoStatus>) null);
        SQLNonTransientException sQLNonTransientException0 = new SQLNonTransientException(sQLClientInfoException0);
        ClassUtil.unwrapAndThrowAsIAE((Throwable) sQLNonTransientException0);
    }

    @Test(timeout = 4000)
    public void test0056() throws Throwable {
        Class<TextNode> class0 = TextNode.class;
        Class<PlaceholderForType> class1 = PlaceholderForType.class;
        List<Class<?>> list0 = ClassUtil.findSuperTypes(class0, class1);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0067() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        CharArrayWriter charArrayWriter0 = new CharArrayWriter();
        objectMapper0.writeValue((Writer) charArrayWriter0, (Object) objectMapper0);
    }

    @Test(timeout = 4000)
    public void test0078() throws Throwable {
        ClassUtil classUtil0 = new ClassUtil();
    }

    @Test(timeout = 4000)
    public void test0089() throws Throwable {
        SQLFeatureNotSupportedException sQLFeatureNotSupportedException0 = new SQLFeatureNotSupportedException("IT!:4qU]n[", "IT!:4qU]n[");
        Throwable throwable0 = ClassUtil.throwRootCauseIfIOE(sQLFeatureNotSupportedException0);
    }

    @Test(timeout = 4000)
    public void test00910() throws Throwable {
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor((Constructor<?>) null);
        classUtil_Ctor0.getDeclaringClass();
    }

    @Test(timeout = 4000)
    public void test01011() throws Throwable {
        Class<AccessibleObject> class0 = AccessibleObject.class;
        List<JavaType> list0 = ClassUtil.findSuperTypes((JavaType) null, class0, false);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01112() throws Throwable {
        Class<Object> class0 = Object.class;
        JavaType javaType0 = TypeFactory.unknownType();
        JavaType[] javaTypeArray0 = new JavaType[2];
        ReferenceType referenceType0 = ReferenceType.construct(class0, (TypeBindings) null, javaType0, javaTypeArray0, javaType0);
        List<JavaType> list0 = ClassUtil.findSuperTypes((JavaType) referenceType0, (Class<?>) class0, true);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01213() throws Throwable {
        Class<ArrayType> class0 = ArrayType.class;
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes((Class<?>) null, class0, false);
        boolean boolean0 = ClassUtil.isJacksonStdImpl((Object) list0);
    }

    @Test(timeout = 4000)
    public void test01314() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        ObjectMapper objectMapper0 = new ObjectMapper();
        objectMapper0.addMixIn(class0, class0);
        ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    }

    @Test(timeout = 4000)
    public void test01415() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<Float> class1 = Float.class;
        SimpleType simpleType0 = SimpleType.constructUnsafe(class1);
        Class<?> class2 = ClassUtil.classOf(simpleType0);
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes(class0, class2, true);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01516() throws Throwable {
        Class<Error> class0 = Error.class;
        Class<Double> class1 = Double.class;
        List<Class<?>> list0 = ClassUtil.findRawSuperTypes(class0, class1, true);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01617() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses((Class<?>) null, class0, false);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test01718() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Class<ResolvedRecursiveType> class1 = ResolvedRecursiveType.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses(class1, class0, false);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01819() throws Throwable {
        Class<Void> class0 = Void.class;
        Class<Object> class1 = Object.class;
        List<Class<?>> list0 = ClassUtil.findSuperClasses(class0, class1, true);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test01920() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        List<Class<?>> list0 = ClassUtil.findSuperTypes(class0, class0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test02021() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        String string0 = ClassUtil.canBeABeanType(class0);
    }

    @Test(timeout = 4000)
    public void test02123() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        String string0 = ClassUtil.canBeABeanType(class0);
    }

    @Test(timeout = 4000)
    public void test02225() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        String string0 = ClassUtil.isLocalType(class0, false);
    }

    @Test(timeout = 4000)
    public void test02326() throws Throwable {
        JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_MISSING_VALUES;
        Class<? extends Enum<?>> class0 = ClassUtil.findEnumType((Enum<?>) jsonParser_Feature0);
        Class<?> class1 = ClassUtil.getOuterClass(class0);
    }

    @Test(timeout = 4000)
    public void test02327() throws Throwable {
        JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_MISSING_VALUES;
        Class<? extends Enum<?>> class0 = ClassUtil.findEnumType((Enum<?>) jsonParser_Feature0);
        Class<?> class1 = ClassUtil.getOuterClass(class0);
        class0.toString();
    }

    @Test(timeout = 4000)
    public void test02328() throws Throwable {
        JsonParser.Feature jsonParser_Feature0 = JsonParser.Feature.ALLOW_MISSING_VALUES;
        Class<? extends Enum<?>> class0 = ClassUtil.findEnumType((Enum<?>) jsonParser_Feature0);
        Class<?> class1 = ClassUtil.getOuterClass(class0);
        class0.getModifiers();
    }

    @Test(timeout = 4000)
    public void test02429() throws Throwable {
        Class<Long> class0 = Long.TYPE;
        boolean boolean0 = ClassUtil.isConcrete(class0);
    }

    @Test(timeout = 4000)
    public void test02530() throws Throwable {
        Class<Long> class0 = Long.class;
        boolean boolean0 = ClassUtil.isConcrete(class0);
    }

    @Test(timeout = 4000)
    public void test02631() throws Throwable {
        Class<String> class0 = String.class;
        Constructor<String> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        boolean boolean0 = ClassUtil.isConcrete((Member) classUtil_Ctor0._ctor);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test02632() throws Throwable {
        Class<String> class0 = String.class;
        Constructor<String> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        boolean boolean0 = ClassUtil.isConcrete((Member) classUtil_Ctor0._ctor);
    }

    @Test(timeout = 4000)
    public void test02733() throws Throwable {
        Class<ResolvedRecursiveType> class0 = ResolvedRecursiveType.class;
        boolean boolean0 = ClassUtil.isCollectionMapOrArray(class0);
    }

    @Test(timeout = 4000)
    public void test02834() throws Throwable {
        Class<Void> class0 = Void.class;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test02935() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03036() throws Throwable {
        Class<Void> class0 = Void.TYPE;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03137() throws Throwable {
        Class<NoClass> class0 = NoClass.class;
        boolean boolean0 = ClassUtil.isBogusClass(class0);
    }

    @Test(timeout = 4000)
    public void test03238() throws Throwable {
        Class<Object> class0 = Object.class;
        boolean boolean0 = ClassUtil.hasClass((Object) null, class0);
    }

    @Test(timeout = 4000)
    public void test03339() throws Throwable {
        Class<?> class0 = ClassUtil.classOf("java.lang.Class@0000000001");
    }

    @Test(timeout = 4000)
    public void test03340() throws Throwable {
        Class<?> class0 = ClassUtil.classOf("java.lang.Class@0000000001");
        boolean boolean0 = ClassUtil.hasClass(class0, (Class<?>) null);
    }

    @Test(timeout = 4000)
    public void test03441() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        ObjectMapper objectMapper1 = objectMapper0.copy();
    }

    @Test(timeout = 4000)
    public void test03542() throws Throwable {
        Class<SimpleType> class0 = SimpleType.class;
        Character character0 = new Character('f');
        ClassUtil.verifyMustOverride(class0, character0, "wc{y` Y]H~$Hn");
    }

    @Test(timeout = 4000)
    public void test03643() throws Throwable {
        SQLClientInfoException sQLClientInfoException0 = new SQLClientInfoException("ftVrySet", (Map<String, ClientInfoStatus>) null);
        SQLRecoverableException sQLRecoverableException0 = new SQLRecoverableException("Malformed numeric value '", "Malformed numeric value '", sQLClientInfoException0);
        MockError mockError0 = new MockError("ftVrySet", sQLRecoverableException0);
        ClassUtil.throwAsIAE((Throwable) mockError0, "Malformed numeric value '");
    }

    @Test(timeout = 4000)
    public void test03744() throws Throwable {
        SQLClientInfoException sQLClientInfoException0 = new SQLClientInfoException();
        BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
        DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
        SQLTransactionRollbackException sQLTransactionRollbackException0 = new SQLTransactionRollbackException("?cBAdrT8HtHi./8S&$t", "; failed to set access: ", sQLClientInfoException0);
        MockIOException mockIOException0 = new MockIOException(sQLTransactionRollbackException0);
        ClassUtil.throwAsMappingException((DeserializationContext) defaultDeserializationContext_Impl0, (IOException) mockIOException0);
    }

    @Test(timeout = 4000)
    public void test03845() throws Throwable {
        BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;
        DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);
        BigDecimal bigDecimal0 = new BigDecimal(53);
        Class<TextNode> class0 = TextNode.class;
        JsonMappingException jsonMappingException0 = defaultDeserializationContext_Impl0.weirdNumberException(bigDecimal0, class0, "-vcWG;0ie7kfSb2Z");
        ClassUtil.throwAsMappingException((DeserializationContext) defaultDeserializationContext_Impl0, (IOException) jsonMappingException0);
    }

    @Test(timeout = 4000)
    public void test03946() throws Throwable {
        SQLTimeoutException sQLTimeoutException0 = new SQLTimeoutException("org.hibernate.proxy.com.fasterxml.jackson.databind.JsonMappingException");
        ClassUtil.closeOnFailAndThrowAsIOE((JsonGenerator) null, (Closeable) null, (Exception) sQLTimeoutException0);
    }

    @Test(timeout = 4000)
    public void test04047() throws Throwable {
        JsonFactory jsonFactory0 = new JsonFactory();
        BufferRecycler bufferRecycler0 = new BufferRecycler();
        ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);
        JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((OutputStream) byteArrayBuilder0);
        JsonGeneratorDelegate jsonGeneratorDelegate0 = new JsonGeneratorDelegate(jsonGenerator0);
        SQLTimeoutException sQLTimeoutException0 = new SQLTimeoutException("JSON");
        ClassUtil.closeOnFailAndThrowAsIOE((JsonGenerator) jsonGeneratorDelegate0, (Closeable) byteArrayBuilder0, (Exception) sQLTimeoutException0);
    }

    @Test(timeout = 4000)
    public void test04148() throws Throwable {
        Class<Double> class0 = Double.class;
        ClassUtil.createInstance(class0, true);
    }

    @Test(timeout = 4000)
    public void test04249() throws Throwable {
        Class<?> class0 = ClassUtil.classOf((Object) null);
    }

    @Test(timeout = 4000)
    public void test04350() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        Class<TextNode> class0 = TextNode.class;
        objectMapper0.readValue((Reader) null, class0);
    }

    @Test(timeout = 4000)
    public void test04451() throws Throwable {
        Class<?> class0 = ClassUtil.rawClass((JavaType) null);
    }

    @Test(timeout = 4000)
    public void test04552() throws Throwable {
        Float float0 = new Float(0.0F);
        Object object0 = ClassUtil.nonNull((Object) float0, (Object) float0);
    }

    @Test(timeout = 4000)
    public void test04653() throws Throwable {
        Double double0 = new Double((-3529.583296));
        Object object0 = ClassUtil.nonNull((Object) null, (Object) double0);
    }

    @Test(timeout = 4000)
    public void test04754() throws Throwable {
        Class<Error> class0 = Error.class;
        String string0 = ClassUtil.nullOrToString(class0);
    }

    @Test(timeout = 4000)
    public void test04855() throws Throwable {
        String string0 = ClassUtil.nullOrToString((Object) null);
    }

    @Test(timeout = 4000)
    public void test04956() throws Throwable {
        String string0 = ClassUtil.nonNullString((String) null);
    }

    @Test(timeout = 4000)
    public void test05057() throws Throwable {
        Class<Object> class0 = Object.class;
        String string0 = ClassUtil.quotedOr(class0, "`java.lang.String`");
    }

    @Test(timeout = 4000)
    public void test05158() throws Throwable {
        String string0 = ClassUtil.quotedOr((Object) null, "`java.lang.String`");
    }

    @Test(timeout = 4000)
    public void test05259() throws Throwable {
        Class<MapType> class0 = MapType.class;
        String string0 = ClassUtil.getClassDescription(class0);
    }

    @Test(timeout = 4000)
    public void test05360() throws Throwable {
        String string0 = ClassUtil.getClassDescription((Object) null);
    }

    @Test(timeout = 4000)
    public void test05461() throws Throwable {
        Short short0 = new Short((short) 0);
        String string0 = ClassUtil.getClassDescription(short0);
    }

    @Test(timeout = 4000)
    public void test05562() throws Throwable {
        String string0 = ClassUtil.classNameOf("3'h>0M_E/RG");
    }

    @Test(timeout = 4000)
    public void test05663() throws Throwable {
        String string0 = ClassUtil.classNameOf((Object) null);
    }

    @Test(timeout = 4000)
    public void test05764() throws Throwable {
        String string0 = ClassUtil.nameOf((Class<?>) null);
    }

    @Test(timeout = 4000)
    public void test05865() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        String string0 = ClassUtil.nameOf(class0);
    }

    @Test(timeout = 4000)
    public void test05966() throws Throwable {
        BeanProperty.Bogus beanProperty_Bogus0 = new BeanProperty.Bogus();
        String string0 = ClassUtil.nameOf((Named) beanProperty_Bogus0);
    }

    @Test(timeout = 4000)
    public void test06067() throws Throwable {
        String string0 = ClassUtil.nameOf((Named) null);
    }

    @Test(timeout = 4000)
    public void test06168() throws Throwable {
        String string0 = ClassUtil.backticked((String) null);
    }

    @Test(timeout = 4000)
    public void test06269() throws Throwable {
        Class<Annotation> class0 = Annotation.class;
        ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06370() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06471() throws Throwable {
        Class<Long> class0 = Long.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06572() throws Throwable {
        Class<Boolean> class0 = Boolean.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06673() throws Throwable {
        Class<Double> class0 = Double.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06774() throws Throwable {
        Class<Float> class0 = Float.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06875() throws Throwable {
        Class<Byte> class0 = Byte.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test06976() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07077() throws Throwable {
        Class<Character> class0 = Character.TYPE;
        Object object0 = ClassUtil.defaultValue(class0);
    }

    @Test(timeout = 4000)
    public void test07178() throws Throwable {
        Class<Short> class0 = Short.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test07279() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isPrimitive();
    }

    @Test(timeout = 4000)
    public void test07380() throws Throwable {
        Class<Long> class0 = Long.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test07481() throws Throwable {
        Class<Boolean> class0 = Boolean.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isAnnotation();
    }

    @Test(timeout = 4000)
    public void test07582() throws Throwable {
        Class<Double> class0 = Double.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test07683() throws Throwable {
        Class<Float> class0 = Float.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isPrimitive();
    }

    @Test(timeout = 4000)
    public void test07784() throws Throwable {
        Class<Byte> class0 = Byte.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isPrimitive();
    }

    @Test(timeout = 4000)
    public void test07885() throws Throwable {
        Class<Character> class0 = Character.TYPE;
        Class<?> class1 = ClassUtil.wrapperType(class0);
        class1.isAnnotation();
    }

    @Test(timeout = 4000)
    public void test07986() throws Throwable {
        Class<IOException> class0 = IOException.class;
        ClassUtil.wrapperType(class0);
    }

    @Test(timeout = 4000)
    public void test08087() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08188() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.isEnum();
    }

    @Test(timeout = 4000)
    public void test08289() throws Throwable {
        Class<Integer> class0 = Integer.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.isPrimitive();
    }

    @Test(timeout = 4000)
    public void test08290() throws Throwable {
        Class<Integer> class0 = Integer.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08391() throws Throwable {
        Class<Long> class0 = Long.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08392() throws Throwable {
        Class<Long> class0 = Long.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08493() throws Throwable {
        Class<Boolean> class0 = Boolean.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08494() throws Throwable {
        Class<Boolean> class0 = Boolean.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08595() throws Throwable {
        Class<Double> class0 = Double.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08596() throws Throwable {
        Class<Double> class0 = Double.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08697() throws Throwable {
        Class<Float> class0 = Float.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test08698() throws Throwable {
        Class<Float> class0 = Float.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test08799() throws Throwable {
        Class<Byte> class0 = Byte.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test087100() throws Throwable {
        Class<Byte> class0 = Byte.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test088101() throws Throwable {
        Class<Short> class0 = Short.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test088102() throws Throwable {
        Class<Short> class0 = Short.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test089103() throws Throwable {
        Class<Character> class0 = Character.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
    }

    @Test(timeout = 4000)
    public void test089104() throws Throwable {
        Class<Character> class0 = Character.class;
        Class<?> class1 = ClassUtil.primitiveType(class0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test090105() throws Throwable {
        Class<String> class0 = String.class;
        Constructor<String> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.checkAndFixAccess((Member) constructor0, false);
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test091106() throws Throwable {
        AccessPattern accessPattern0 = AccessPattern.CONSTANT;
        EnumSet<AccessPattern> enumSet0 = EnumSet.of(accessPattern0, accessPattern0);
        Class<? extends Enum<?>> class0 = ClassUtil.findEnumType(enumSet0);
        class0.getModifiers();
    }

    @Test(timeout = 4000)
    public void test092107() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        EnumMap<AccessPattern, Character> enumMap0 = new EnumMap<AccessPattern, Character>(class0);
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(enumMap0);
        class1.getModifiers();
    }

    @Test(timeout = 4000)
    public void test093108() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        EnumMap<AccessPattern, Character> enumMap0 = new EnumMap<AccessPattern, Character>(class0);
        AccessPattern accessPattern0 = AccessPattern.CONSTANT;
        enumMap0.put(accessPattern0, (Character) null);
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(enumMap0);
        class1.toString();
    }

    @Test(timeout = 4000)
    public void test094109() throws Throwable {
        Class<AccessPattern> class0 = AccessPattern.class;
        ObjectMapper objectMapper0 = new ObjectMapper();
        ObjectWriter objectWriter0 = objectMapper0.writerFor(class0);
        objectWriter0.hasPrefetchedSerializer();
    }

    @Test(timeout = 4000)
    public void test095110() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<? extends Enum<?>> class1 = ClassUtil.findEnumType(class0);
    }

    @Test(timeout = 4000)
    public void test096111() throws Throwable {
        boolean boolean0 = ClassUtil.isJacksonStdImpl((Object) null);
    }

    @Test(timeout = 4000)
    public void test097112() throws Throwable {
        Class<Object> class0 = Object.class;
        ObjectMapper objectMapper0 = new ObjectMapper();
        ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    }

    @Test(timeout = 4000)
    public void test098113() throws Throwable {
        Class<Integer> class0 = Integer.TYPE;
        String string0 = ClassUtil.getPackageName(class0);
    }

    @Test(timeout = 4000)
    public void test099114() throws Throwable {
        Class<Object> class0 = Object.class;
        Class<?> class1 = ClassUtil.getOuterClass(class0);
    }

    @Test(timeout = 4000)
    public void test100115() throws Throwable {
        ObjectMapper objectMapper0 = new ObjectMapper();
        Class<Annotation> class0 = Annotation.class;
        ObjectReader objectReader0 = objectMapper0.readerFor(class0);
    }

    @Test(timeout = 4000)
    public void test101116() throws Throwable {
        Class<Double> class0 = Double.class;
        Class<?> class1 = ClassUtil.getDeclaringClass(class0);
    }

    @Test(timeout = 4000)
    public void test102117() throws Throwable {
        Class<Double> class0 = Double.TYPE;
        Class<?> class1 = ClassUtil.getDeclaringClass(class0);
    }

    @Test(timeout = 4000)
    public void test103118() throws Throwable {
        Class<Object> class0 = Object.class;
        Constructor<Object> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getDeclaredAnnotations();
        Annotation[] annotationArray0 = classUtil_Ctor0.getDeclaredAnnotations();
        constructor0.isAccessible();
    }

    @Test(timeout = 4000)
    public void test103119() throws Throwable {
        Class<Object> class0 = Object.class;
        Constructor<Object> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getDeclaredAnnotations();
        Annotation[] annotationArray0 = classUtil_Ctor0.getDeclaredAnnotations();
    }

    @Test(timeout = 4000)
    public void test104120() throws Throwable {
        Class<String> class0 = String.class;
        Constructor<String> constructor0 = ClassUtil.findConstructor(class0, false);
        ClassUtil.Ctor classUtil_Ctor0 = new ClassUtil.Ctor(constructor0);
        classUtil_Ctor0.getParameterAnnotations();
        classUtil_Ctor0.getParameterAnnotations();
        constructor0.isAccessible();
    }
}
