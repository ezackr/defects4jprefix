/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 06:56:25 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.StatementFusion;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test000() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "nOSTRB");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0, "I$RF^jvu1(N&9+ !R6}", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(100, node0, node0, node0, 5, 53);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test011() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        Node node1 = new Node(33, 40, (-2584));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test022() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(googleCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(37, node0, node0, 57, 31);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test033() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Z{", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(101, 39, 56);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test044() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        Node node1 = new Node(30, node0, node0, (-2245), 44);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableMap0);
    }

    @Test(timeout = 4000)
    public void test055() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("}X\"FDcT", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test066() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("k65", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
        controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test077() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Key");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
        controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test088() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(".e=*%sl=TWcEK");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.SYN_BLOCK;
        controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test099() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(";9-8\"X/OhAY};J");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.google.javascript.jscomp.TypeInference", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(4, node0, node0, node0, 54, 400000);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1010() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = Node.newString(5, "STRIP", 31, (-25));
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("STRIP", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Node node1 = new Node(8, 100, 57);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1212() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(10, 46, 0);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1313() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(12, 47, 30);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1414() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("+E;LZw>B'p_/");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("s!F", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(14, node0, node0, node0, 37, 30);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1515() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("STRIP", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Node node1 = new Node(15, 16, 16);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1616() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(16, 57, 4);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1717() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("STRIP", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(17, 687, 1535);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1818() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(21, 117, 48);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1919() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = Node.newString(24, "STRIP", 31, (-42));
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createGlobalScope(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2020() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = Node.newString(28, "STRIP", 31, (-42));
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2121() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STR3IP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("STR3IP", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(29, 57, 31);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2222() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(30, node0, node0, node0, 46, 1);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2323() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Z{", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(31, 48, 4020);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2424() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("}X\"FDcT", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(32);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2525() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("TRI");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("TRI", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(35, node0, node0, node0, 42, 30);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2626() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRII");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = Node.newString(36, "STRII", 31, (-42));
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2727() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = Node.newString(38, "com.google.javascript.rhino.head.ast.ElementGet");
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2828() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(39, node0, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2929() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = Node.newString("Object#Key");
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3030() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(42, 8, (-1163));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3131() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(43, 4095, 40);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3232() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "S2TR");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(46, 109, 55);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3333() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(47, node0, node0, node0, 50, 50);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3434() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(48, 53, 65);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3535() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = Node.newString(49, "STRIP", 31, (-42));
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3636() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(50, node0, node0, 5, (-2363));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3737() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(52, 2, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3838() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(53);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test3939() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) hashMap0);
        Node node1 = new Node(54, 52, 40);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4040() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("STRIP");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Key", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(55, 2951, 37);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4141() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(56);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4242() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(57);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4343() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "S8RIlP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.goo)le.javascript.jcomp.TypeIAference", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(62, node0, node0, node0, 52, (-2611));
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4444() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(64, 57, 40);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4545() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIlP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("-SW&jneOh!?x8");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Ogt}", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(71, 4, 140);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4646() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "S8RIlP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.google.javascript.jscomp.TypeIAference", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(74, node0, node0, node0, 52, (-2611));
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4747() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "S8RIlP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("7jHe?zNoA6eas!BWr!@", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(81, 37, 141);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4848() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Lcd6S65J");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("STRIP", codingConvention_AssertionFunctionSpec0, "Hi)h7&", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(83, 113, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4949() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = Node.newString(51, "com.google.javascript.rhino.head.ast.ElementGet", 31, 48);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node2 = StatementFusion.fuseExpressionIntoExpression(node0, node1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5050() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createGlobalScope(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(90, node0, node0, node0, 147, 57);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test5151() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIlP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("UOWh`K5W Rrj", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(93, 48, 137);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test5252() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("k65", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(98, node0, node0, node0, 30, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5353() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = Node.newString(104, "com.google.javascript.rhino.head.ast.ElementGet", 31, 29);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5454() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("}X\"FDcT", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(105, 100, 36);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5555() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("}X\"FDcT", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(109, (-133), 36);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5656() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(111);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test5757() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("TRI");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(112, 4095, 31);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5858() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("// Input %num%");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(113, node0, node0, node0, 12, (-888));
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test5959() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(114, (-858), 43);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6060() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "S8RIlP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("G/955Op%=");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.google.javascript.jscomp.TypeIAference", codingConvention_AssertionFunctionSpec0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(115, 12, 140);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6161() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(116, 38, (-984));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6262() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRII");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode$NeighborIterator");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("\"eval\" cannot be redeclared in ES5 strict mode", codingConvention_AssertionFunctionSpec0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = Node.newString(117, "Object#Element");
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test6363() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(118, 771, (-289));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(119, node0, node0, node0, 43, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6565() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "SzRID");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(120, 2876, 57);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6666() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(121, 121, (-1388));
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test6767() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0, (SyntacticScopeCreator.RedeclarationHandler) null);
        Scope scope0 = syntacticScopeCreator0.createScope(node0, (Scope) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(122, 50, 32);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test6868() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.jscomp.TypeInference$1");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.google.javascript.jscomp.TypeInference$1", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(123, 151, 36);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test6969() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = Node.newString(124, "com.google.javascript.rhino.head.ast.ElementGet", 31, 29);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7070() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(125, 147, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7171() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("* YJM7Iwm$Q*t7wnIX", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(126, 30, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7272() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STR3IP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("STR3IP", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(128, node0, node0, node0, 147, 2);
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test7373() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "tSTRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("* YJM7Iwm$Q*t7wnIX", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(129, 32, 47);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7474() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Heo2wL?J8#TQ,B-/A\"t");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("}X\"FDcT", codingConvention_AssertionFunctionSpec0, "Ydt&u0BP", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(131, 56, 4095);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test7575() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(133, node0, node0, node0, 46, 2);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test7676() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.google.javascript.jscomp.TypeInference$TemplateTypeReplacer", codingConvention_AssertionFunctionSpec0);
        Node node1 = new Node(134, 38, 50);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7777() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "VTIRPP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(135, (-2521), 57);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7878() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(136, 37, 39);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7979() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(137, (-3509), (-2487));
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8080() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Node node1 = Node.newString(138, "", 1877, 36);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8181() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.copyOf((Map<? extends String, ? extends CodingConvention.AssertionFunctionSpec>) hashMap0);
        Node node1 = new Node(139, 52, 40);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8282() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = Node.newString(140, "com.google.javascript.rhino.head.ast.ElementGet", 31, (-42));
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8383() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0, (SyntacticScopeCreator.RedeclarationHandler) null);
        Scope scope0 = syntacticScopeCreator0.createScope(node0, (Scope) null);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("4v");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Unknown marker", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(141, node0, node0, node0, 1, 2);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8484() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(143, node0, node0, node0, 46, 2);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8585() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(144, node0, node0, node0, 43, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8686() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "TRI");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Hi)h7&", codingConvention_AssertionFunctionSpec0, "I$RF^jvu1(N&9+ !R6}", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(146);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8787() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(147, (-1612), 33);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8888() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("TRI");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention((CodingConvention) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("-k");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(148, node0, node0, node0, 130, 36);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8989() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("TRI");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("Object#Element");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("Object#Element", codingConvention_AssertionFunctionSpec0);
        Node node1 = new Node(149, 31, 2996);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9090() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(googleCodingConvention0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(150, node0, node0, node0, 46, 2);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test9191() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("com.google.javascript.jscomp.TypeInference", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(151, 2, 36);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test9292() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("|", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(152, 57, 118);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test9393() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = compiler0.parseTestCode("com.google.javascript.rhino.head.ast.ElementGet");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        Node node1 = Node.newString(153, "com.google.javascript.rhino.head.ast.ElementGet", 53, 115);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("com.google.javascript.rhino.head.ast.ElementGet");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("TightenTypes pass appears to be stuck in an infinite loop.", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9494() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(154, 37, 39);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9595() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "STRIP");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("// Input %num%", codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(2, 33, 46);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9696() throws Throwable {
        Compiler compiler0 = new Compiler((PrintStream) null);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "S2TR");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = Node.newString(4, "S2TR", 126, 38);
        Scope scope0 = Scope.createLatticeBottom(node0);
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec("");
        ImmutableMap<String, CodingConvention.AssertionFunctionSpec> immutableMap0 = ImmutableMap.of("*cO", codingConvention_AssertionFunctionSpec0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, immutableMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9797() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    }

    @Test(timeout = 4000)
    public void test9898() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.FALSE;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    }
}
