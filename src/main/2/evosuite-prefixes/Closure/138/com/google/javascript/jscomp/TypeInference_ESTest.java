/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 08:29:38 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NamedType;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.TreeSet;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test000() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
        Node node1 = new Node(101, node0, node0, node0, 126, 49);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test011() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(86, 102, (-25));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test022() throws Throwable {
        Logger logger0 = Logger.getGlobal();
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("c-Q~~x !Sa~afZ#+?", 0, (-587));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, linkedList0);
        Node node1 = Node.newString(63, "msg.no.brace.switch", 0, 10);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test033() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("", 3605, (-516));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(100, "");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test044() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE", 0, 1479);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
    }

    @Test(timeout = 4000)
    public void test055() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 1034);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(33);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test066() throws Throwable {
        Logger logger0 = Logger.getLogger(":reur");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("N]=eal4>s,H", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        linkedList0.addLast((Scope.Var) null);
        TypeInference typeInference0 = null;
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
    }

    @Test(timeout = 4000)
    public void test077() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test088() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
        Node node1 = new Node(4, node0, node0, node0, 4095, 7);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test099() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        Node node1 = Node.newString(5, "");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1010() throws Throwable {
        Logger logger0 = Logger.getLogger(":reur");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseTestCode(":reur");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(6, (-2704), 115);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
        Node node1 = new Node(7, node0, node0, node0, 4, 2301);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1212() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("", 3605, (-516));
        Node node1 = new Node(8, node0, node0, node0, 40, 7);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1313() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1598));
        Node node1 = new Node(9, node0, node0, 34, (-2));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1414() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        Node node1 = new Node(11, node0, node0, node0, 44, (-776));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1515() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        Node node1 = Node.newString(12, "com.googlecommoncollect.AbstractSetMultimap", 4095, 1);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1616() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("c-Q~~ !Sa~afZ#+?", 1249, 1249);
        Node node1 = new Node(13, node0, node0, node0, 1498, 1);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test1717() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(14);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test1818() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(130, "j[hkC8g5[UQSK/", 0, 38);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(15, "j[hkC8g5[UQSK/");
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test1919() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE", 0, 1479);
        Node node1 = new Node(16, node0, node0, node0, (-582), 12);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2020() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("c-Q~ !SAa~af#+?", 0, 0);
        Node node1 = Node.newString(17, "c-Q~ !SAa~af#+?");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2121() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        Node node1 = Node.newString(18, "\"T|*o9@Q");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2222() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("c-Q~~ !Sa~afZ#+?", 0, (-587));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(19, "");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2323() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("c-Q~~ !Sa~afZ#+?", 1249, 1249);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(20, "com.google.javascript.jscomp.NameReferenceGraph$Name");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test2424() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("wc.MP^5nK.NR%o-", 0, (-587));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = new Node(21, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2525() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 3227, 117);
        Node node1 = new Node(22, node0, node0, node0, 3, 4095);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test2626() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("c-Q~ !SAa~af#+?", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(23, "&Smkw*0q-t,$G");
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2727() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("wc.MP^5nK.NR%o-", 1364, 1364);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(24, "&Smkw*0q-t,$G");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2828() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1598));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(25);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test2929() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
        Node node1 = new Node(26, node0, node0, node0, 47, 48);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3030() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
        Node node1 = new Node(27, node0, 2, 1);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3131() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("wc.MP^5nK.NR%o-", 1364, 1364);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = Node.newString(28, "wc.MP^5nK.NR%o-");
        typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3232() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
        Node node1 = Node.newString(29, "com.googlecommoncollect.AbstractSetMultimap", 1, 130);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3333() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("wc.MP^5nK.NR%o-", 1364, 1364);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(30, 77, 35);
        typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3434() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("", 0, (-587));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(31, "", 41, 952);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test3535() throws Throwable {
        Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultim}p");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
        node0.setType(32);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test3636() throws Throwable {
        Logger logger0 = Logger.getLogger(":rePr");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseTestCode(":rePr");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(34, ":rePr", 15, 809);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test3737() throws Throwable {
        Logger logger0 = Logger.getLogger(":reur");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseTestCode(":reur");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(36, 15, 30);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test3838() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newNumber((-1500.8320871930864), 123, 123);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        NamedType namedType0 = new NamedType(jSTypeRegistry0, "fvq#N@lGxz", (String) null, (-5135), 0);
        Scope scope0 = new Scope(node0, namedType0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
        TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
        FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test3939() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 0, 0);
        Node node1 = new Node(41, node0, node0, node0, 2157, 710);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4040() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        node0.setType(42);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4141() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
        Node node1 = Node.newString(43, "");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4242() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("W7e4/lv>i)k{u/7Hs5", (-600), (-600));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(44);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test4343() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = new Node(45, 27, 28);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4444() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        CodingConvention codingConvention0 = compiler0.getCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, codingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, linkedList0);
        node0.setType(46);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test4545() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("41etrn", (-19), (-19));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(47, 16, (-24));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4646() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        Node node1 = Node.newString(48, "\"T|*o9@Q", (-3547), (-2392));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test4747() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("", 3605, (-516));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(51, "Cannot read: {0}");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4848() throws Throwable {
        Logger logger0 = Logger.getLogger(":reur");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseTestCode(":reur");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node1 = Node.newString(53, "TightenTypes pass appears to be stuck in an infinite loop.");
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test4949() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("inlineConstants", 1249, 1249);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(58, 1249, 83);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5050() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(70);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5151() throws Throwable {
        Logger logger0 = Logger.getGlobal();
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("c-Q~~x !Sa~afZ#+?", 0, (-587));
        Node node1 = new Node(72, node0, node0, node0, 1, 40);
        Node node2 = new Node(49, node1, node1, node1, 12, 26);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test5252() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(2883);
        Node node1 = new Node(74, node0, node0, node0, 950, 1);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5353() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
        node0.setType(83);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5454() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("", 3582, (-516));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(84, "");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test5555() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        node0.setType(85);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5656() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test5757() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(89);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test5858() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
        Node node1 = Node.newString(90, "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test5959() throws Throwable {
        Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%oo-");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = Node.newString("c-Q~ !SAa~af#+?", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(91, 25, 45);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6060() throws Throwable {
        Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(93);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6161() throws Throwable {
        Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node1 = Node.newString(94, "TightenTypes pass appears to be stuck in an infinite loop.");
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test6262() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(95, "`*KL8W\"|()Aa^Rj%I", 3034, 3034);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test6363() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(117, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(96, "TightenTypes pass appears to be stuck in an infinite loop.");
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(97);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test6565() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        Node node1 = Node.newString(99, "", 83, 12);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test6666() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", (-1598), 100);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        node0.setType(102);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test6767() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(1249, "km<o+x", 54, 91);
        Node node1 = new Node(103, node0, node0, node0, 94, 54);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test6868() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("A function type with the template type as the type of this must be a parameter type", 85, 1872);
        Node node1 = new Node(104, node0, node0, node0, 4095, 2);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test6969() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7070() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("3wvmy", 127, 111);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
        node0.setType(107);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test7171() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
        Node node1 = new Node(108, node0, node0, node0, 950, 38);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7272() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(109, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test7373() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1600));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(110);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7474() throws Throwable {
        Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultim}p");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(111);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test7575() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        Node node1 = Node.newString(114, "\"T|*o9@Q", (-3590), (-2392));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test7676() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        node0.setType(115);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test7777() throws Throwable {
        Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
        node0.setType(116);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test7878() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(117, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test7979() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        node0.setType(118);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test8080() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("", (-56), 4633);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(119, node0, node0, 0, 33);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8181() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node1 = Node.newString(121, "~Eyi\".~BU");
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8282() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(122, "wc.MP^5nK.NR%o-");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8383() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(124);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test8484() throws Throwable {
        Logger logger0 = Logger.getLogger(":reur");
        LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
        Compiler compiler0 = new Compiler(loggerErrorManager0);
        Node node0 = compiler0.parseTestCode(":reur");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test8585() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(126, "JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test8686() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 2883);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node0.setType(127);
        LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope1);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test8787() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("41etrn", (-19), (-19));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(129, node0, node0, 101, 6);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8888() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("prototype", 93, 93);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = new Node(130, node0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test8989() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
        Node node1 = Node.newString(38, "wc.MP^5nK.NR%o-");
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test9090() throws Throwable {
        Node node0 = Node.newString("kpGA3u4//Op", (-5299), (-5299));
        Node node1 = new Node(35, node0, node0, node0, 48, 136);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Compiler compiler0 = new Compiler();
        TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test9191() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
        Node node1 = new Node(101, node0, node0, node0, 126, 49);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, linkedList0);
        node0.setType((-3));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9292() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    }

    @Test(timeout = 4000)
    public void test9393() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Node.newString(":return", 2883, 2883);
        Node node1 = new Node(117, node0, node0, 35, 13);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node1);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node1.setType(120);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test9494() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(2883);
        Node node1 = new Node(74, node0, node0, node0, 950, 1);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        node1.setType(37);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }
}
