/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 01:04:23 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Normalize;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.JSDocInfo;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.HashMap;
import java.util.List;
import java.util.TreeMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(120, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        Node node1 = new Node(33, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(63, node0, node0, node0, 32, 41);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = Node.newString("", 4095, 1271);
        Node node2 = new Node(30, node1, node0, node0, (-2432), 43);
        typeInference0.branchedFlowThrough(node2, flowScope0);
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack dgth", "Exceeded mtimum stack dgth");
        Node node1 = new Node(91, 36, 39);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node2 = new Node(101, node1, node0, node0, 51, 2);
        node0.detachFromParent();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("}_5d1GCH[-fZ");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = compiler0.parseTestCode("}_5d1GCH[-fZ");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(86, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeAnference$1", "com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(100, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("w=oYk^K,f!?9*h?)#v");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
        controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascr|t.jucomp.TypInference$1", "com.google.javascr|t.jucomp.TypInference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
        controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01010() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("w=oYk^K,f!?9*h?)#v");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
        controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01111() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "E{ADm7h", "E{ADm7h");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(4, node0, node0, node0, 8, 35);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01212() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "RJ/VhEK(xsA%!", "RJ/VhEK(xsA%!");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(5, node0, node0, node0, 36, 36);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01313() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "RJ/VhEK(xsA%!", "RJ/VhEK(xsA%!");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(6, node0, node0, node0, 36, 36);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01414() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(7, node0, node0, node0, 1, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01515() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSC_FUNCTION_LITERAL_UNDEFINED_THIS", "JSC_FUNCTION_LITERAL_UNDEFINED_THIS");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(8, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01616() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(9, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01717() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("}_5ed1GCH:-Xj+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(10, node0, node0, node0, 8, (-1784));
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test01818() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "goog.tweak.getCompilerOverrides_", "goog.tweak.getCompilerOverrides_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        Node node1 = new Node(11, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01919() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "J?hL^ver;\"9%5gd,=", "J?hL^ver;\"9%5gd,=");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(12, node0, node0, node0, 1, 50);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02020() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "ELceeded maximum stack depth", "ELceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(13, node0, node0, node0, 42, 45);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02121() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("}M_5ed1GCH[-f3+Z");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "}M_5ed1GCH[-f3+Z", "}M_5ed1GCH[-f3+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(14, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02222() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "RJ/VhEK(xsA%!", "RJ/VhEK(xsA%!");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(15, node0, node0, node0, 36, 36);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02323() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$h~hn", "CT?PF$h~hn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(16, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02424() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("ELceeded maximum stack depth");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "ELceeded maximum stack depth", "ELceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(17, node0, node0, node0, 42, 45);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02525() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$1", "com.google.javascript.jscomp.TypeInference$1");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(18, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02626() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("}_5ed1GCH:-X3+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(19, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02727() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("}_5ed1GCH:-Xj+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(20, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02828() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("}_5ed1GCH[-f3+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(21, node0, node0, node0, 40, (-839));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02929() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(22, node0, node0, node0, 15, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03030() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "/Fm(WMW]k_hJv2", "/Fm(WMW]k_hJv2");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        Node node1 = new Node(23, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03131() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("}_5ed1GCH[-f3+Z");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = compiler0.parseTestCode("}_5ed1GCH[-f3+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(24, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03232() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE", "JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(25, node0, node0, node0, 481, 16);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03333() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("}_5ed1GCH[-f3+Z");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = compiler0.parseTestCode("}_5ed1GCH[-f3+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(26, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03434() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(27, node0, node0, node0, 1, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03535() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "goog.twea[.getCompilerOverrides_", "goog.twea[.getCompilerOverrides_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        Node node1 = new Node(28, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03636() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(29, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03737() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "vt|FdY\"H?Lzu{SdMK58", "vt|FdY\"H?Lzu{SdMK58");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(30, node0, node0, node0, 49, 32);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03838() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(32, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03939() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(34, "");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04040() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeAnference$1", "com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(35, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04141() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("T?&F$hKn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(36, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04242() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.goog)e.javascript.jscomp.TypKInference$1", "com.goog)e.javascript.jscomp.TypKInference$1");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(37, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04343() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(39, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04444() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "@'RU+%#X1h8\"[", "@'RU+%#X1h8\"[");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(41, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04545() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "s\\*}u@", "s\\*}u@");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(42, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04646() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(43, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04747() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "k1RV~Prh79YMQL<:f;", "k1RV~Prh79YMQL<:f;");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = new Node(46, node0, node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04848() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(47, node0, node0, 31, 40);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04949() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "RJ/VhEK(xsA%!", "RJ/VhEK(xsA%!");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(48, node0, node0, node0, 36, 36);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05050() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(49, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05151() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "k1RV~Prh79YMQL<:f;", "k1RV~Prh79YMQL<:f;");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = new Node(50, node0, node0, node0, 31, 4095);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05252() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(51, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05353() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$1", "com.google.javascript.jscomp.TypeInference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(52, node0, node0, node0, 47, 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05454() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(53, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05555() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "J?hL^ver;\"9%5gd,=", "J?hL^ver;\"9%5gd,=");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05656() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(55, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05757() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "k1RV~Prh79YMQL<:f;", "k1RV~Prh79YMQL<:f;");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        Node node1 = new Node(58, node0, node0, node0, 31, 4095);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05858() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "T?7P$hhn", "T?7P$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(59, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05959() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("T?7$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(60, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06060() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(61, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06161() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "$", "$");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(62, node0, node0, node0, 54, 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06262() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("T?7$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(64, node0, node0, node0, 2, 43);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06363() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        CodingConvention codingConvention0 = compiler0.getCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(65, node0, node0, node0, 8, 16);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06464() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(66, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06565() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(67, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06666() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("Exceeded maximum stack depth");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(68, node0, node0, node0, 1, 32);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test06767() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(69, node0, node0, node0, 32, 41);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06868() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack deth", "Exceeded mtimum stack deth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(70, node0, node0, node0, 51, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06969() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(71, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07070() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "T?7P$hhn", "T?7P$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(72, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07171() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(73, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07272() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack deth", "Exceeded mtimum stack deth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(74, node0, node0, node0, 51, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07373() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "%][xHI^ q^E{W]w^nDZ", "%][xHI^ q^E{W]w^nDZ");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(75, node0, node0, node0, 54, 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07474() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair", "Exeeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(76, 3803, 47);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test07575() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "w]H$j2TOuVQ", "w]H$j2TOuVQ");
        Scope scope0 = new Scope(node0, compiler0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(77, node0, (-821), 200000);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07676() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeAnference$1", "com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(78, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07777() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(79, node0, node0, node0, 12, 64336);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07878() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$1", "com.google.javascript.jscomp.TypeInference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(80, node0, node0, node0, 54, 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07979() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "roYqVU4b6l1eo?", "roYqVU4b6l1eo?");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(81, node0, node0, node0, 32, 41);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08080() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(82, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08181() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "wH$j2TOuVQ", "wH$j2TOuVQ");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(83);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08282() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stackdeth", "Exceeded mtimum stackdeth");
        Node node1 = new Node(84, 36, 39);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node2 = new Node(101, node1, node0, node0, 51, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08383() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "J?hL^ver;\"9%5gd,=", "J?hL^ver;\"9%5gd,=");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(85, node0, node0, node0, 43, 41);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08484() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("wH$j2TOuVQ");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = compiler0.parseTestCode("^");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(87, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08585() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "T?7P$hhn", "T?7P$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(88, node0, node0, node0, 46, 16);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08686() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("T?&F$hKn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(89, node0, node0, node0, 42, 160);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08787() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$1", "com.google.javascript.jscomp.TypeInference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(90, node0, node0, node0, 32, 3252);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08888() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(92, "");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08989() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("ELceeded maximum stack depth");
        MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "ELceeded maximum stack depth", "ELceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(94, node0, node0, node0, 50, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09090() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stackdeth", "Exceeded mtimum stackdeth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(95, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09191() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(96, node0, node0, node0, 32, 44);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09292() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("RHINO USAGE WARNING: onExit terminated with exception");
        MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "RHINO USAGE WARNING: onExit terminated with exception", "RHINO USAGE WARNING: onExit terminated with exception");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(97, node0, node0, node0, 51, 53);
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test09393() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "goog.tweak.getCompilerOverrides_", "goog.tweak.getCompilerOverrides_");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        Node node1 = new Node(99, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09494() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$hhn", "CT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(102, node0, node0, node0, 48, 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09595() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "CT?PF$h~hn", "CT?PF$h~hn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = new Node(103, node0, node0, node0, 4, 126);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09696() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stackdeth", "Exceeded mtimum stackdeth");
        Node node1 = new Node(104, 36, 39);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test09797() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeAnference$1", "com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(105, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09898() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeAnference$1", "com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(106, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09999() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "(z.(jy", "(z.(jy");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(107, node0, node0, node0, 12, 127);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test100100() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(108, node0, node0, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test101101() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(109, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test102102() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeAnfence$1", "com.google.javascript.jscomp.TypeAnfence$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(110, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test103103() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.TypeAnference$1", "com.google.javascript.jscomp.TypeAnference$1");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(111, "com.google.javascript.jscomp.TypeAnference$1");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test104104() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(112, node0, node0, node0, 46, 200000);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test105105() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Node node1 = new Node(113, 36, 39);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test106106() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.google.javascript.jscomp.TypeInference$1", "com.google.javascript.jscomp.TypeInference$1");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(114, node0, node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test107107() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("Exceeded maximum stack depth");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(115, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test108108() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(116, "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test109109() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(117, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test110110() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("c_5ed1GCH-~Xj+Z", "c_5ed1GCH-~Xj+Z");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node1 = new Node(118, node0, node0, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test111111() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("w=oYk^K,f!?9*h?)#v");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Node node1 = new Node(119, node0, node0, node0, 15, 37);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test112112() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "rCT?PF$hhn", "rCT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(121, node0, node0, node0, (-1951), 38);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test113113() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("T?&F$hKn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(122, node0, node0, node0, 1843, 39);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test114114() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "T?7P$hhn", "T?7P$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(123, node0, node0, node0, 54, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test115115() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Function literal argument refers to undefined this argument", "Function literal argument refers to undefined this argument");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(124, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test116116() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "%][xHI^ q^E{W]w^nDZ", "%][xHI^ q^E{W]w^nDZ");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(125, node0, node0, node0, 1837, 38);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test117117() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "rCT?PF$hhn", "rCT?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        Node node1 = new Node(126, node0, node0, node0, 52, 29);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test118118() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack depth", "Exceeded mtimum stack depth");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(127, node0, node0, node0, 40, 51);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test119119() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(128, node0, node0, node0, 94, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test120120() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("T?PF$hhn");
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(129, node0, node0, node0, 29, (-4014));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test121121() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "6]]$j2XTOuVQ", "6]]$j2XTOuVQ");
        Scope scope0 = new Scope(node0, compiler0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(130, node0, node0, node0, 54, 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test122122() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.goog)e.javascript.jscomp.TypKInference$1", "com.goog)e.javascript.jscomp.TypKInference$1");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        JSDocInfo jSDocInfo0 = new JSDocInfo();
        node0.setJSDocInfo(jSDocInfo0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test123123() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(4, 47, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test124124() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "E{ADm7h", "E{ADm7h");
        Node node1 = new Node(45, 36, 29);
        Scope scope0 = new Scope(node1, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node2 = new Node(4, node0, node1, node1, 8, 35);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test125125() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "", "");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(38, "");
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test126126() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("}_5ed1GCH[-f3+Z");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = compiler0.parseTestCode("}_5ed1GCH[-f3+Z");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention((CodingConvention) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Normalize.parseAndNormalizeSyntheticCode(compiler0, "", "}_5ed1GCH[-f3+Z");
        Node node2 = new Node(93, node1, node1, node0, 4095, 41);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test127127() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockPrintStream mockPrintStream0 = new MockPrintStream("com/google/javascript/rhino/head/ScriptRuntime");
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = compiler0.parseTestCode("com/google/javascript/rhino/head/ScriptRuntime");
        Scope scope0 = new Scope(node0, compiler0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Normalize.parseAndNormalizeSyntheticCode(compiler0, "com/google/javascript/rhino/head/ScriptRuntime", "com/google/javascript/rhino/head/ScriptRuntime");
        JSType jSType0 = jSTypeRegistry0.createNamedType("!ag36>{A#-HJX2}>8;", "!ag36>{A#-HJX2}>8;", 15, 31);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("com/google/javascript/rhino/head/ScriptRuntime", node1, jSType0);
        node1.setJSType(enumType0);
        Node node2 = new Node(93, node1, node1, node0, 4095, 41);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test128128() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "(z.(jy", "(z.(jy");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = Node.newString(44, "(z.(jy", 4095, 16);
        Node node2 = new Node(98, node0, node0, node1, 44, 52);
        typeInference0.branchedFlowThrough(node2, flowScope0);
    }

    @Test(timeout = 4000)
    public void test129129() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "com.goog)e.javascript.jscomp.TypKInference$1", "com.goog)e.javascript.jscomp.TypKInference$1");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
        CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec((String) null);
        hashMap0.put((String) null, codingConvention_AssertionFunctionSpec0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(37, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test130130() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream("Exceeded maximum stack depth");
        MockPrintStream mockPrintStream0 = new MockPrintStream(mockFileOutputStream0);
        Compiler compiler0 = new Compiler(mockPrintStream0);
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded maximum stack depth", "Exceeded maximum stack depth");
        Node node1 = new Node(31, 36, 130);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node2 = new Node(35, node1, node0, node1, 47, 29);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test131131() throws Throwable {
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        Compiler compiler0 = new Compiler();
        Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, "Exceeded mtimum stack deth", "Exceeded mtimum stack deth");
        Node node1 = new Node(91, 36, 39);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        Scope scope0 = new Scope(node0, compiler0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
        Node node2 = new Node(101, node1, node0, node0, 51, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test132132() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    }
}
