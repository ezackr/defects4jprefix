/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 00:03:42 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.CheckAccidentalSemicolon;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.CheckMissingGetCssName;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ExternExportsPass;
import com.google.javascript.jscomp.FindExportableNodes;
import com.google.javascript.jscomp.FlowSensitiveInlineVariables;
import com.google.javascript.jscomp.GatherRawExports;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.OptimizeArgumentsArray;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.StrictModeCheck;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("Q4/Fn.Rl", 83, 83);
        Node node1 = new Node(35, node0, node0, node0, node0, 40, 4);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        Node node0 = Node.newString(153, "80Odp9Qq!iL,rl");
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isReturn();
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("kZ%3)McmMx", 1, 1);
        Node node1 = new Node(52, node0, node0, 37, 1471);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.processForTesting(node0, node0);
        typeCheck0.process(node0, node1);
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("kZ%3)McmMx", 1, 1);
        Node node1 = new Node(50, node0, node0, node0, node0, 55, 46);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Scope scope0 = typeCheck0.processForTesting((Node) null, node0);
        scope0.isGlobal();
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("kZ%3)McmMx", 1, 1);
        Node node1 = new Node(52, node0, node0, 37, 1471);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.processForTesting(node0, node0);
        typeCheck0.process(node1, node0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType[] jSTypeArray0 = new JSType[0];
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(jqueryCodingConvention0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, syntacticScopeCreator0, checkLevel0, checkLevel0);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Node node0 = compiler0.parseSyntheticCode("SC_UNRESOLVED_TYPE", "SC_UNRESOLVED_TYPE");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Scope scope0 = new Scope(node0, compiler0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, compilerOptions0.checkUnreachableCode, compilerOptions0.checkMissingReturn);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(98);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(86, 86, 86);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.shouldTraverse(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01010() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(118);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01111() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(125);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01212() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("SC_UNRESOLVED_TYPE", "SC_UNRESOLVED_TYPE");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        node0.addSuppression((String) null);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01313() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(149);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test01314() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(149);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01415() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CompilerOptions compilerOptions0 = compiler0.options;
        Node node0 = new Node((-1079));
        Node node1 = new Node(4, node0, node0, node0, node0, 35, 15);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test01516() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        Node node0 = new Node(5);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01617() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        Node node0 = Node.newString("xE=_[EDTzVX{VUw", 6, 5);
        Node node1 = new Node(6, node0, node0, node0, node0, 37, 5643);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test01718() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(7);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01819() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        Node node1 = new Node(8, node0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test01920() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Node node0 = new Node(9, 0, 49);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0, syntacticScopeCreator0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, (JSTypeRegistry) null);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02021() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType[] jSTypeArray0 = new JSType[0];
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        CheckLevel checkLevel0 = CheckLevel.WARNING;
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, jqueryCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, syntacticScopeCreator0, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
        Node node1 = new Node(10, node0, node0, node0, node0, (-2538), 55);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test02022() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType[] jSTypeArray0 = new JSType[0];
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        CheckLevel checkLevel0 = CheckLevel.WARNING;
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, jqueryCodingConvention0);
        Scope scope0 = typedScopeCreator0.createInitialScope(node0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, syntacticScopeCreator0, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
        Node node1 = new Node(10, node0, node0, node0, node0, (-2538), 55);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test02123() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(11);
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, (ScopeCreator) null, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02224() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 98, 98);
        Node node1 = new Node(12, node0, node0, 4, 50);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isInc();
    }

    @Test(timeout = 4000)
    public void test02325() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(13);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02426() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(14);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02527() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("msg.undef.prop.delete", 579, 579);
        Node node1 = new Node(16, node0, node0, node0, node0, 44, 4095);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isInstanceOf();
    }

    @Test(timeout = 4000)
    public void test02628() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(17);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02729() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(2940);
        Node node1 = new Node(18, node0, node0, 1601, 8);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test02730() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(2940);
        Node node1 = new Node(18, node0, node0, 1601, 8);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test02731() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(2940);
        Node node1 = new Node(18, node0, node0, 1601, 8);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test02832() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(19);
        Scope scope0 = new Scope(node0, compiler0);
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02933() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        Node node1 = new Node(20);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test03034() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(21, (-1406), 113);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test03135() throws Throwable {
        Compiler compiler0 = new Compiler();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        compiler0.getErrorManager();
        Node node0 = new Node(22);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0, (ScopeCreator) null);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, (JSTypeRegistry) null);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test03236() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("#E.*\\Q", 113, 113);
        Node node1 = new Node(23, node0, node0, (-2512), 35);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test03237() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("#E.*\\Q", 113, 113);
        Node node1 = new Node(23, node0, node0, (-2512), 35);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test03338() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("kZ%3)McmMx");
        Node node1 = new Node(27, node0, node0, node0, node0, 55, 46);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isThis();
    }

    @Test(timeout = 4000)
    public void test03439() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(28);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test03540() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("Q4/Fn.Rl", 83, 83);
        Node node1 = new Node(29, node0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isDec();
    }

    @Test(timeout = 4000)
    public void test03641() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("Q4/Fn.Rl", 83, 83);
        Node node1 = new Node(30, node0, node0, node0, node0, 38, 12);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test03742() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(31);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isRegExp();
    }

    @Test(timeout = 4000)
    public void test03843() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        Node node1 = new Node(32, 39, 32);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isGetterDef();
    }

    @Test(timeout = 4000)
    public void test03944() throws Throwable {
        Compiler compiler0 = new Compiler();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Node node0 = Node.newString("kZ%3)McmMx");
        Node node1 = new Node(33, node0, node0, node0, node0, 55, 46);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Scope scope0 = new Scope(node0, compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, syntacticScopeCreator0, compilerOptions0.aggressiveVarCheck, compilerOptions0.checkRequires);
        typeCheck0.check(node1, false);
    }

    @Test(timeout = 4000)
    public void test04045() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(34);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test04146() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("kZ%3)McmMx");
        Node node1 = new Node(36, node0, node0, node0, node0, 55, 46);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test04247() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 75, 75);
        Node node1 = new Node(37, node0, node0, node0, node0, 12, 55);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test04348() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 92, 115);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Node node1 = Node.newNumber((-784.13795));
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node1.isThis();
    }

    @Test(timeout = 4000)
    public void test04449() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        Node node1 = new Node(41, node0, node0, node0, node0, 2000, 30);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test04550() throws Throwable {
        Compiler compiler0 = new Compiler();
        FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
        compiler0.getErrorManager();
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 309, 1371);
        Node node1 = new Node(42, node0, node0, node0, node0, 309, 44);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test04651() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(149);
        Node node1 = new Node(43, node0, node0, 49, 2);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test04752() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        Node node1 = new Node(44);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node1.isDo();
    }

    @Test(timeout = 4000)
    public void test04853() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node((-6));
        Node node1 = new Node(45, node0, node0, 43, 50);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test04954() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node((-1079));
        Node node1 = new Node(46, node0, node0, node0, node0, 140, 43);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node1.isNot();
    }

    @Test(timeout = 4000)
    public void test05055() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(92);
        Node node1 = new Node(47);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isNot();
    }

    @Test(timeout = 4000)
    public void test05156() throws Throwable {
        Compiler compiler0 = new Compiler();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        compiler0.getErrorManager();
        Node node0 = new Node((-642));
        CompilerOptions compilerOptions0 = new CompilerOptions();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Node node1 = new Node(48);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, (JSTypeRegistry) null, (Scope) null, syntacticScopeCreator0, compilerOptions0.checkUnreachableCode, compilerOptions0.checkGlobalNamesLevel);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test05257() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(49);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test05358() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(113, 113, 113);
        Node node1 = new Node(50, node0, node0, node0, node0, 46, 0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test05459() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("kZ%3)McmMx", 1, 1);
        Node node1 = new Node(52, node0, node0, 37, 1471);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test05560() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType[] jSTypeArray0 = new JSType[0];
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
        Node node1 = new Node(53, node0, node0, node0, node0, 55, 2);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test05661() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(113, 453, 113);
        Node node1 = new Node(54, node0, node0, node0, node0, 116, 139);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test05762() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = new Node(55);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test05863() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(58);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test05964() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("Q4/Fn.Rl", 83, 83);
        Node node1 = new Node(59, node0, node0, node0, node0, 8, 55);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test06065() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(61);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06166() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(63);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isWith();
    }

    @Test(timeout = 4000)
    public void test06267() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(65);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06368() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(69);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06469() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(72);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06570() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(73);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06671() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(76);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06772() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(78);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06873() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(79);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06974() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        Node node0 = new Node(80);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07075() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(81);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07176() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType[] jSTypeArray0 = new JSType[0];
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isVar();
    }

    @Test(timeout = 4000)
    public void test07277() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        ExternExportsPass externExportsPass0 = new ExternExportsPass(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, externExportsPass0, syntacticScopeCreator0);
        Node node0 = Node.newString(84, "TightenTypes pass appears to be stuck in an infinite loop.");
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07378() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(85);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07479() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(87);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07580() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newNumber((double) 89, 89, 543);
        Node node1 = new Node(89, node0, node0, 24, 15);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test07581() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newNumber((double) 89, 89, 543);
        Node node1 = new Node(89, node0, node0, 24, 15);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test07682() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(92);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07783() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(93);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07884() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(94);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test07985() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(95);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08086() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(97);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        FindExportableNodes findExportableNodes0 = new FindExportableNodes(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, findExportableNodes0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08187() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(98);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        double double0 = typeCheck0.getTypedPercent();
    }

    @Test(timeout = 4000)
    public void test08288() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(99);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08389() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(100);
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, (ScopeCreator) null, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08490() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(101, 101, 101);
        Scope scope0 = new Scope(node0, compiler0);
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, checkLevel0, checkLevel0);
        typeCheck0.check(node0, false);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test08491() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(101, 101, 101);
        Scope scope0 = new Scope(node0, compiler0);
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, checkLevel0, checkLevel0);
        typeCheck0.check(node0, false);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test08592() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(102);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08693() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        Node node0 = new Node(104);
        Scope scope0 = new Scope(node0, compiler0);
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, checkLevel0, checkLevel0);
        typeCheck0.check(node0, true);
    }

    @Test(timeout = 4000)
    public void test08794() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08895() throws Throwable {
        Compiler compiler0 = new Compiler();
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Node node0 = Node.newString("", 134, 134);
        Node node1 = new Node(106, node0, node0, 42, 1);
        GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, gatherRawExports0, syntacticScopeCreator0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test08996() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(107);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test09097() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(108);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isNew();
    }

    @Test(timeout = 4000)
    public void test09198() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(109);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test09299() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(110);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isAnd();
    }

    @Test(timeout = 4000)
    public void test093100() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(111);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test094101() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(112);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test095102() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(113, 113, 113);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test096103() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(114, 114, 114);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isContinue();
    }

    @Test(timeout = 4000)
    public void test097104() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(115);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test098105() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(116);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test099106() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(117);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test100107() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(119);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test101108() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(120);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isDefaultCase();
    }

    @Test(timeout = 4000)
    public void test102109() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(121);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test103110() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(123);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test104111() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(124);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, compilerOptions0.aggressiveVarCheck, "// Input %num%");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test105112() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(126);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.getSourceOffset();
    }

    @Test(timeout = 4000)
    public void test106113() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(127);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test107114() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(128);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test108115() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(129);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test109116() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        Node node0 = new Node(131);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test110117() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(133);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test111118() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Node node0 = new Node(134);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0, syntacticScopeCreator0);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test112119() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(135);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test113120() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(136);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test114121() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(137);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test115122() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Node node0 = Node.newString("= E,)8tv:9]%R");
        Node node1 = new Node(138, node0, node0, node0, node0, 139, (-2618));
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Scope scope0 = new Scope(node1, compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, syntacticScopeCreator0, compilerOptions0.reportMissingOverride, compilerOptions0.checkGlobalThisLevel);
        typeCheck0.check(node1, false);
    }

    @Test(timeout = 4000)
    public void test116123() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Node node0 = new Node(139);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, typedScopeCreator0, compilerOptions0.reportMissingOverride, compilerOptions0.checkMissingGetCssNameLevel);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test117124() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(140);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test118125() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(141);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test119126() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(142);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test120127() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(143);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test121128() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(144);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test122129() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(145);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test123130() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(146);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test124131() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(147);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.getCharno();
    }

    @Test(timeout = 4000)
    public void test125132() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        Node node0 = new Node(148);
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, (ScopeCreator) null, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isNull();
    }

    @Test(timeout = 4000)
    public void test126133() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(150);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit((NodeTraversal) null, node0, node0);
    }

    @Test(timeout = 4000)
    public void test127134() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(151);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        StrictModeCheck strictModeCheck0 = new StrictModeCheck(compiler0, false, false);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, strictModeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test128135() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(152);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test129136() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("Q4/Fn.Rl", 663, 663);
        Node node1 = new Node(154, node0, node0, node0, node0, 49, 31);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isRegExp();
    }

    @Test(timeout = 4000)
    public void test130137() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Node node0 = compiler0.parseSyntheticCode("SC_UNRESOLVED_TYPE", "SC_UNRESOLVED_TYPE");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        Node node1 = new Node((-1045), node0, node0, node0, node0, 29, 29);
        Scope scope0 = new Scope(node0, compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, compilerOptions0.checkMissingReturn, compilerOptions0.checkGlobalNamesLevel);
        typeCheck0.check(node1, false);
    }

    @Test(timeout = 4000)
    public void test131138() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, (ScopeCreator) null);
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 602, (-3732));
        Node node1 = new Node(33, node0, node0, node0, node0, 15, (-338));
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test132139() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("msg.undef.prop.delete", 602, 602);
        Node node1 = new Node(16, node0, node0, node0, node0, 44, 4095);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test133140() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(122);
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0, (ScopeCreator) null);
        Node node1 = new Node(15, node0, node0, node0, node0, 145, 35);
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node1.isName();
    }

    @Test(timeout = 4000)
    public void test134141() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(105);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test135142() throws Throwable {
        Compiler compiler0 = new Compiler();
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        Node node0 = new Node(120);
        Scope scope0 = new Scope(node0, compiler0);
        CheckLevel checkLevel0 = CheckLevel.WARNING;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, checkLevel0, checkLevel0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test136143() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType[] jSTypeArray0 = new JSType[0];
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs(jSTypeArray0);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test137144() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(118);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test138145() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CheckLevel checkLevel0 = CheckLevel.ERROR;
        CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(checkLevel0);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0, (ScopeCreator) null);
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 602, (-3732));
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(118, node0, node0, node0, node0, 49, 16);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test139146() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("Q4/Fn.Rl", 83, 83);
        Node node1 = new Node(30, node0, node0, node0, node0, 38, 12);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test140147() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("TightenTypes pass appears to be stuck in an infinite loop.", 75, 75);
        Node node1 = new Node(37, node0, node0, node0, node0, 12, 55);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test141148() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(24);
        Node node1 = new Node(24, node0, node0, node0, node0, 116, (-1962));
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkRequires);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test141149() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = new Node(24);
        Node node1 = new Node(24, node0, node0, node0, node0, 116, (-1962));
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        CheckAccidentalSemicolon checkAccidentalSemicolon0 = new CheckAccidentalSemicolon(compilerOptions0.checkRequires);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccidentalSemicolon0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test142150() throws Throwable {
        Compiler compiler0 = new Compiler();
        FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0);
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, typedScopeCreator0, checkLevel0, checkLevel0);
        Vector<JSType> vector0 = new Vector<JSType>();
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) vector0);
        Node node1 = new Node(25, node0, node0, node0, node0, 32, (-272));
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test142151() throws Throwable {
        Compiler compiler0 = new Compiler();
        FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0);
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        CheckLevel checkLevel0 = CheckLevel.OFF;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, typedScopeCreator0, checkLevel0, checkLevel0);
        Vector<JSType> vector0 = new Vector<JSType>();
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) vector0);
        Node node1 = new Node(25, node0, node0, node0, node0, 32, (-272));
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test143152() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString("");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        node0.addSuppression("TightenTypes pass appears to be stuck in an infinite loop.");
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test144153() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        double double0 = typeCheck0.getTypedPercent();
    }
}
