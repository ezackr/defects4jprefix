/*
 * This file was automatically generated by EvoSuite
 * Fri Apr 05 23:36:26 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.CheckSuspiciousCode;
import com.google.javascript.jscomp.CleanupPasses;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ConstCheck;
import com.google.javascript.jscomp.ControlFlowAnalysis;
import com.google.javascript.jscomp.FieldCleanupPass;
import com.google.javascript.jscomp.FunctionNames;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.MemoizedScopeCreator;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.OptimizeArgumentsArray;
import com.google.javascript.jscomp.RecordFunctionInformation;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.StrictModeCheck;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforxStandrdOwtiEiatiOns", "beforxStandrdOwtiEiatiOns");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(50, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(35, 37, 306654252);
        compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(71, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforxStandrdOwtiEiatiOns", "beforxStandrdOwtiEiatiOns");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Node node1 = new Node(96, node0, 30, 42);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test0034() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforxStandrdOwtiEiatiOns", "beforxStandrdOwtiEiatiOns");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Node node1 = new Node(96, node0, 30, 42);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test0045() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandacdOp&imizations", "beforeStandacdOp&imizations");
        OptimizeArgumentsArray optimizeArgumentsArray0 = new OptimizeArgumentsArray(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, optimizeArgumentsArray0);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(52, node0, 39, 46);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.getChildCount();
    }

    @Test(timeout = 4000)
    public void test0056() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        Node node1 = new Node(127, node0, (-280), 42);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.processForTesting(node0, node0);
        typeCheck0.process(node0, node1);
    }

    @Test(timeout = 4000)
    public void test0067() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(99, 904, 904);
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        Node node1 = new Node(0, node0, 112, 2);
        CheckLevel checkLevel0 = CheckLevel.WARNING;
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0, checkLevel0, checkLevel0);
        typeCheck0.processForTesting((Node) null, node0);
    }

    @Test(timeout = 4000)
    public void test0078() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(12, node0, 121, 1);
        typeCheck0.processForTesting(node0, node0);
        typeCheck0.process(node1, node0);
    }

    @Test(timeout = 4000)
    public void test0089() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(37, node0, 4, 32);
        typeCheck0.processForTesting(node0, node0);
        typeCheck0.processForTesting(node1, node0);
    }

    @Test(timeout = 4000)
    public void test00910() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(95, 904, 904);
        Node node1 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Scope scope0 = syntacticScopeCreator0.createScope(node0, (Scope) null);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (MemoizedScopeCreator) null, compilerOptions0.checkMissingGetCssNameLevel, compilerOptions0.checkProvides);
        typeCheck0.processForTesting(node1, node1);
    }

    @Test(timeout = 4000)
    public void test01011() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("linNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.processForTesting(node0, node0);
    }

    @Test(timeout = 4000)
    public void test01112() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("JSC_NVALID_CAS", "JSC_NVALID_CAS");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(105, "JSC_NVALID_CAS");
        nodeTraversal0.traverse(node0);
    }

    @Test(timeout = 4000)
    public void test01213() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("m)hKQ~O</H\"S'", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(118, "Tv");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test01314() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("<9Ec0kW'ndK6RJm%[]0");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(125, "5~oK{._hBeai}}");
        typeCheck0.visit(nodeTraversal0, node0, (Node) null);
        node0.isRegExp();
    }

    @Test(timeout = 4000)
    public void test01415() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("[&DuN](H;E1k", "5");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        node0.addSuppression("// Input %num%");
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.getLineno();
    }

    @Test(timeout = 4000)
    public void test01516() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Node node0 = compiler0.parseSyntheticCode("'.'", "FILTER_BY_PATH");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Node node1 = new Node(18, node0, 48, 51);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(typedScopeCreator0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
        nodeTraversal0.traverse(node1);
        nodeTraversal0.getSourceName();
    }

    @Test(timeout = 4000)
    public void test01617() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(4, node0, node0, node0, node0, 4, 32);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test01718() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("Q/)C(;S;':r#");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(5, "com.google.javascript.jscomp.Compiler$11");
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test01819() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        Node node0 = compiler0.parseSyntheticCode("lineNumber", "lineNumber");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(6, node0, 47, (-3191));
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test01920() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Node node0 = compiler0.parseSyntheticCode("'.'", "'.'");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        Node node1 = Node.newString(7, "");
        FunctionNames functionNames0 = new FunctionNames(compiler0);
        RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test02021() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(8, node0, 48, 1);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test02122() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSCompiler_renameProperty", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(9, node0, 29, 38);
        typeCheck0.visit(nodeTraversal0, node1, (Node) null);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test02123() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSCompiler_renameProperty", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(9, node0, 29, 38);
        typeCheck0.visit(nodeTraversal0, node1, (Node) null);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test02224() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_NAME_REFERENCE_IN_EXTERNS", "JSC_NAME_REFERENCE_IN_EXTERNS");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(10, node0, 43, 147);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test02225() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_NAME_REFERENCE_IN_EXTERNS", "JSC_NAME_REFERENCE_IN_EXTERNS");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(10, node0, 43, 147);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test02326() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandacdOp&imizations", "beforeStandacdOp&imizations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test02327() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandacdOp&imizations", "beforeStandacdOp&imizations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test02428() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_NVALID_CAS", "JSC_NVALID_CAS");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(12, node0, 1562, 2);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test02529() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Node node0 = compiler0.parseSyntheticCode("'.'", "'.'");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        FunctionNames functionNames0 = new FunctionNames(compiler0);
        RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        Node node1 = new Node(13, node0, 46, 30);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        nodeTraversal0.getSourceName();
    }

    @Test(timeout = 4000)
    public void test02630() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(14, node0, 29, 4095);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test02731() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(15, node0, 39, 40);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isDefaultCase();
    }

    @Test(timeout = 4000)
    public void test02832() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("com.google.jNvascriRt.jscomp.ReplacStrins", "lin$eNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(16, "");
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test02933() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(17, 129, 3304);
        compiler0.parseSyntheticCode("beforeStandardOptimizations", "JSC_CONSTRUCTOR_NOT_CALLABLE");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test03034() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(76, 904, 904);
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        CheckSuspiciousCode checkSuspiciousCode0 = new CheckSuspiciousCode();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkSuspiciousCode0);
        Node node1 = new Node(19, node0, 49, 2305);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test03035() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(76, 904, 904);
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        CheckSuspiciousCode checkSuspiciousCode0 = new CheckSuspiciousCode();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkSuspiciousCode0);
        Node node1 = new Node(19, node0, 49, 2305);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test03036() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(76, 904, 904);
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        CheckSuspiciousCode checkSuspiciousCode0 = new CheckSuspiciousCode();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkSuspiciousCode0);
        Node node1 = new Node(19, node0, 49, 2305);
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test03137() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(20, 904, 904);
        compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
        nodeTraversal0.traverse(node0);
    }

    @Test(timeout = 4000)
    public void test03238() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(21, node0, 147, 20);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test03239() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(21, node0, 147, 20);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test03340() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        Node node1 = Node.newString(22, "prototype");
        Node node2 = new Node(0, node0, node1);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.processForTesting(node1, node1);
    }

    @Test(timeout = 4000)
    public void test03441() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(23, "Illegal annotation on {0}. @implicitCast may only be used in externs.");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test03542() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("T,6/B", "T,6/B");
        Node node1 = new Node(25, node0, 53, 16);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test03543() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("T,6/B", "T,6/B");
        Node node1 = new Node(25, node0, 53, 16);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test03644() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(26, node0, 29, 138);
        typeCheck0.visit(nodeTraversal0, node1, (Node) null);
        node1.isInc();
    }

    @Test(timeout = 4000)
    public void test03745() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        StrictModeCheck strictModeCheck0 = new StrictModeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, strictModeCheck0);
        Node node1 = new Node(27, node0, 55, (-2803));
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.getCharno();
    }

    @Test(timeout = 4000)
    public void test03846() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(28, 28, (-2));
        Node node1 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test03947() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(29, node0, 32, 4);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test04048() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(30, node0, (-1326), 0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test04149() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandacdOp&imizations", "beforeStandacdOp&imizations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(31);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isStringKey();
    }

    @Test(timeout = 4000)
    public void test04250() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(32, node0, 136, 30);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        node1.isEmpty();
    }

    @Test(timeout = 4000)
    public void test04351() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test04352() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test04453() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(3195, 3195, 3195);
        Node node1 = compiler0.parseSyntheticCode("%uyrK,@ou", "JSC_IMPLEMENTS_NON_INTERFACE");
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        FieldCleanupPass.QualifiedNameSearchTraversal fieldCleanupPass_QualifiedNameSearchTraversal0 = new FieldCleanupPass.QualifiedNameSearchTraversal(jSTypeRegistry0, "JSC_INVALID_CAST");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, fieldCleanupPass_QualifiedNameSearchTraversal0);
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        Node node2 = new Node(34, node1, node0, node0);
        typeCheck0.visit(nodeTraversal0, node2, node2);
    }

    @Test(timeout = 4000)
    public void test04554() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "vv2");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        Node node1 = new Node(36, node0, 55, 46);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test04655() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("]sO+L%@.Au8nVtUA14q");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(42, node0, 8, 4095);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test04756() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Node node0 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(44, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isInc();
    }

    @Test(timeout = 4000)
    public void test04857() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.jNvascriRt.jscomp.ReplacStrins", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(45, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, (Node) null);
    }

    @Test(timeout = 4000)
    public void test04958() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("could not determine the type of this expression", "beforeStandardOptimizations");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(46, node0, 4, 1);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node1.isThrow();
    }

    @Test(timeout = 4000)
    public void test05059() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(47, node0, (-3237), 149);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.getChildCount();
    }

    @Test(timeout = 4000)
    public void test05160() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(48, "");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test05261() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("T,6/B", "T,6/B");
        Node node1 = new Node(49, node0, node0);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test05262() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("T,6/B", "T,6/B");
        Node node1 = new Node(49, node0, node0);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test05363() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(51, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isDebugger();
    }

    @Test(timeout = 4000)
    public void test05464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        CheckSuspiciousCode checkSuspiciousCode0 = new CheckSuspiciousCode();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkSuspiciousCode0);
        Node node1 = new Node(53, node0, 37, 51);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test05565() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(54, node0, node0, 49, 53);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test05666() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrOptimations", "beforeStandrOptimations");
        Node node1 = Node.newString(55, "beforeStandrOptimations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test05767() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(56);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test05868() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("SCINVALI_CAT", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node0 = Node.newString(59, "ARRAYCOMP");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test05969() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Optimization level outside [-1..9]: ");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(65, node0, 49, 52);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test06070() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "vv2");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(66, node0, 12, 42);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test06171() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("<9Ec0kW'ndK6RJm%[]0");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(67, node0, node0, node0, node0, 30, 30);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test06272() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(69, 904, 904);
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06373() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("SCINVALI_CAT", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node0 = Node.newString(72, "ARRAYCOMP");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06474() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(74, 74, 74);
        Node node1 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonmmutableMap", "com.google.common.collect.SingletonmmutableMap");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test06575() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(76, 904, 904);
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test06676() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(79, 904, 904);
        Node node1 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test06777() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.jNvascriRt.jscomp.ReplacStrins", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(80, "wWMU");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test06878() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Vector<JSType> vector0 = new Vector<JSType>(49, 4095);
        Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) vector0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test06979() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(86, 904, 904);
        Node node1 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test07080() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(94, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test07081() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(94, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test07182() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(95, 95, 95);
        Node node1 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test07283() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.ReplaceStrings", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(97, node0, 1712, 1985);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test07284() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.ReplaceStrings", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(97, node0, 1712, 1985);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test07385() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(101, node0, 386, 29);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test07486() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_NVALID_CAS", "JSC_NVALID_CAS");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(105, "JSC_NVALID_CAS");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test07587() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Interface {0} has a property {1} with incompatible types in its super interfaces {2} and {3}");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(106, node0, 1, 50);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test07688() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSCompiler_renameProperty", "");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(107, "#f8mZPR,q[/,\"+V");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test07789() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        Node node0 = Node.newString(108, "MAPPED");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        nodeTraversal0.traverse(node0);
        node0.isAssign();
    }

    @Test(timeout = 4000)
    public void test07890() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(109, node0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test07991() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("7TO5NXw7P6", "lin$eNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(110, "");
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.getChildCount();
    }

    @Test(timeout = 4000)
    public void test08092() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandacdOp&imizations", "beforeStandacdOp&imizations");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(111, node0, 1, 12);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test08193() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforxStandrdOwtiEiatiOns", "beforxStandrdOwtiEiatiOns");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        Node node1 = new Node(112, node0, 30, 42);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.getType();
    }

    @Test(timeout = 4000)
    public void test08294() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(113, node0, node0, node0, node0, 114, 83);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
        node1.isNew();
    }

    @Test(timeout = 4000)
    public void test08395() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforxStandrdOwtiEiatiOns", "beforxStandrdOwtiEiatiOns");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Node node1 = new Node(114, node0, 30, 42);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test08496() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(115, "$");
        typeCheck0.visit(nodeTraversal0, node0, node0);
        node0.isGetElem();
    }

    @Test(timeout = 4000)
    public void test08597() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(116, "$");
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test08698() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(117, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node1.isTrue();
    }

    @Test(timeout = 4000)
    public void test08799() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(119, 151, 151);
        compiler0.parseSyntheticCode("beforeStandardOptimizations", "wrapDouble");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test088100() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(120, node0, 36, 46);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isSwitch();
    }

    @Test(timeout = 4000)
    public void test089101() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(121, node0, 15, 40);
        typeCheck0.visit(nodeTraversal0, node1, (Node) null);
    }

    @Test(timeout = 4000)
    public void test090102() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(122, "+");
        nodeTraversal0.traverse(node0);
        node0.isOr();
    }

    @Test(timeout = 4000)
    public void test091103() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(123, node0, 146, (-2510));
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test092104() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("<9Ec0kW'ndK6RJm%[]0");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node0 = Node.newString(124, "Array index not integer: {0}");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, (Node) null);
        node0.isParamList();
    }

    @Test(timeout = 4000)
    public void test093105() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("linNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        Node node0 = Node.newString(126, "funbtion {0} masks varoable (IE bug)");
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        typeCheck0.visit((NodeTraversal) null, node0, node0);
    }

    @Test(timeout = 4000)
    public void test094106() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node0 = Node.newString(127, "JSC_ENUM_NOT_CONSTANT");
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        nodeTraversal0.traverse(node0);
    }

    @Test(timeout = 4000)
    public void test095107() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("Internal Error: Don't know how to handle {0}");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(128);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test096108() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(129, 129, 2975);
        compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test097109() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(131, node0, 12, 42);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test098110() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("lineNumber", "lineNumber");
        Node node0 = new Node(133, 48, 38);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test099111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(134, node0, 12, 42);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test100112() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("lineNumber", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(135, node0, 51, 22);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test101113() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandacdOp&imizations", "beforeStandacdOp&imizations");
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
        ConstCheck constCheck0 = new ConstCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, constCheck0);
        Node node1 = new Node(136, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test102114() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("JSC_INEXISTENT_ENUM_ELEMENT");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(137, "QbfKS+N_Xu*E");
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test103115() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(138, node0, 29, 153);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test104116() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(139, 1, 40);
        compiler0.parseSyntheticCode("befoeStandardOptimizations", "befoeStandardOptimizations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test105117() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.jNvascriRt.jscomp.ReplacStrins", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(140, node0, 8, 155);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test106118() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(141, (-1129), (-129));
        compiler0.parseSyntheticCode("]ut53GZz6~fOE", "ujS");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test107119() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        Node node1 = new Node(142, node0, 30, 16);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test108120() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0, syntacticScopeCreator0);
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(143, node0, node0, node0, node0, 2, 1791);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test109121() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        Node node1 = new Node(144, node0, 30, 16);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test110122() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(146, node0, 55, 5578);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test111123() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(147, 1, 40);
        Node node1 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        typeCheck0.visit(nodeTraversal0, node0, node1);
        node1.isThrow();
    }

    @Test(timeout = 4000)
    public void test112124() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("[&DuN](H;E1k", "5");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = Node.newString(148, "");
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isAdd();
    }

    @Test(timeout = 4000)
    public void test113125() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("m)hKQ~O</H\"S'", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(149, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test113126() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("m)hKQ~O</H\"S'", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(149, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test114127() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(150, node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test115128() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node(151, 151, 2975);
        compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = new CompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test116129() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("lineNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        CheckSuspiciousCode checkSuspiciousCode0 = new CheckSuspiciousCode();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkSuspiciousCode0);
        Node node1 = new Node(154, node0, 37, 51);
        typeCheck0.visit(nodeTraversal0, node1, node1);
    }

    @Test(timeout = 4000)
    public void test117130() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("linNumber");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(155, node0, 55, 4095);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    }

    @Test(timeout = 4000)
    public void test118131() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.jNvascriRt.jscomp.Repracjtrins", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(2, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test119132() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode(" argument(s)", " argument(s)");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test120133() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        cleanupPasses0.regenerateGlobalTypedScope(compiler0, node0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(15, node0, 39, 40);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        node0.isTrue();
    }

    @Test(timeout = 4000)
    public void test121134() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compilerOptions0.setReportUnknownTypes(compilerOptions0.brokenClosureRequiresLevel);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(18, node0, (-1326), 0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.hasErrors();
    }

    @Test(timeout = 4000)
    public void test121135() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandardOptimizations", "beforeStandardOptimizations");
        CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
        compilerOptions0.setReportUnknownTypes(compilerOptions0.brokenClosureRequiresLevel);
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        Node node1 = new Node(18, node0, (-1326), 0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getErrorCount();
    }

    @Test(timeout = 4000)
    public void test122136() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        Node node0 = compiler0.parseSyntheticCode("increment/decrement", "lieNumber");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(120, node0, 36, (-250));
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test123137() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = new Node((-1971), 109, (-1971));
        compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Vector<JSType> vector0 = new Vector<JSType>(49, 4095);
        Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) vector0);
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
    }

    @Test(timeout = 4000)
    public void test124138() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("m)hKQ~O</H\"S'", "lineNumber");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node0 = Node.newString(118, "Tv");
        boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    }

    @Test(timeout = 4000)
    public void test125139() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.common.collect.SingletonImmutableMap", "com.google.common.collect.SingletonImmutableMap");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test126140() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("JSC_INVALID_CAST", "JSC_INVALID_CAST");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(118, node0, 12, 42);
        typeCheck0.visit(nodeTraversal0, node1, node0);
    }

    @Test(timeout = 4000)
    public void test127141() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(37, node0, 4, 32);
        typeCheck0.processForTesting(node0, node0);
        typeCheck0.visit(nodeTraversal0, node1, node0);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test128142() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseTestCode("<9Ec0kW'ndK6RJm%[]0");
        CompilerOptions compilerOptions0 = compiler0.getOptions();
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
        Node node1 = new Node(43, node0, 55, 38);
        node1.addSuppression(":");
        typeCheck0.visit(nodeTraversal0, node1, node1);
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test129143() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Node node0 = compiler0.parseSyntheticCode("'.'", "FILTER_BY_PATH");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(typedScopeCreator0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
        nodeTraversal0.traverse(node0);
        double double0 = typeCheck0.getTypedPercent();
    }

    @Test(timeout = 4000)
    public void test129144() throws Throwable {
        Compiler compiler0 = new Compiler();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        Node node0 = compiler0.parseSyntheticCode("'.'", "FILTER_BY_PATH");
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
        TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
        MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(typedScopeCreator0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, memoizedScopeCreator0);
        nodeTraversal0.traverse(node0);
        double double0 = typeCheck0.getTypedPercent();
        compiler0.getWarningCount();
    }

    @Test(timeout = 4000)
    public void test130145() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.parseSyntheticCode("beforeStandrdOptimiations", "beforeStandrdOptimiations");
        CompilerOptions compilerOptions0 = compiler0.options;
        CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
        TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
        double double0 = typeCheck0.getTypedPercent();
    }
}
