/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 11:43:34 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableSortedMap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.JqueryCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SourceFile;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.FlowScope;
import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test0000() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javscript.jscomp.TypeInference$BooleanOtcomePkiM");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(100, node0, 52, 55);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0011() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        node0.setType(46);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test0022() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(101, node0, 29, 29);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0033() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
        list0.isEmpty();
    }

    @Test(timeout = 4000)
    public void test0044() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.jvascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = Node.newString(86, "JRn3Ux&t:0", (-35), 39);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0055() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.gogle.javascripl.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = new Node(30, node0, 48, 135);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
    }

    @Test(timeout = 4000)
    public void test0066() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("_?Ico0lTrU!-Lme", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
        controlFlowGraph0.connect(node0, controlFlowGraph_Branch0, node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0077() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(4, node0, 400000, 36);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0088() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(5, node0, 15, 8);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test0099() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(6, node0, 4, (-2262));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01010() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(8, node0, 38, 649);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01111() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(10, node0, 2, (-828));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01212() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javscript.jscomp.TypeInference$BooleanOtcomePkiM");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(11, node0, 135, 50);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01313() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(12, node0, 4, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01414() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(14, node0, 89, 2695);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01515() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(15, node0, (-508), 46);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01616() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(16, node0, node0, node0, node0, 52, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01717() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function limeral argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(17, "Object#Element", 136, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01818() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(18, node0, 18, 37);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test01919() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(25, node0, 43, 40);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02020() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(27, node0, 42, (-1686));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02121() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(28, node0, 43, 40);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02222() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(29, node0, 29, 47);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02323() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypnInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(30, node0, 121, (-1538));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02424() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(31, node0, 3633, 57);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02525() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        Node node1 = new Node(32, node0, 133, (-459));
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02626() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?xco0lTrU!-Lrg", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(36, node0, 49, 1);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test02727() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(39, node0, 1, 48);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02828() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(42, node0, 52, 4095);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test02929() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(43, node0, 30, 31);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test03030() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(44, node0, 51, 37);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        list0.size();
    }

    @Test(timeout = 4000)
    public void test03131() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("=q/U1Jdpvv\u0001V{ZProx", "com.google.javascript.jscom.TypeInference$BoolenOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(45, node0, 2, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03232() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        Scope scope0 = Scope.createLatticeBottom(node0);
        ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(47, node0, (-2384), 54);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03333() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(48, node0, 2, (-370));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03434() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(49, node0, (-280), 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03535() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "_");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        Node node1 = Node.newString(50, "Object#Element", (-1714), 4);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03636() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Rw/T!8[/.Cga;4b7\"", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(51, node0, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03737() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(52, node0, 400000, 4);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03838() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(53, node0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test03939() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(54, node0, 15, 42);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04040() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("_?Ico0lTrU!-Lme", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(55, node0, (-310), 1267);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04141() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.zypeInference$BooleanOutcomePair", "com.google.javascript.jscomp.zypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(56, node0, node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04242() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(57, node0, 1, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04343() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(61, node0, 2, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04444() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(62, node0, 4162, 2097);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04545() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("_?Ico0lTrU!-Lme", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(65, node0, 65, 37);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04646() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("A`8t&#h^X(6![]~", "U");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(67, node0, 4095, 55);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04747() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(68, node0, 1, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04848() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(70, node0, 70, 37);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test04949() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscomp.TypeInference");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = Node.newString(73, "Object#Key", 47, 51);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05050() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(78, node0, 4095, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05151() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("=q/U1Jdpvv\u0001V{ZProx", "com.google.javascript.jscom.TypeInference$BoolenOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(80, node0, 2, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05252() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("A`8t&#h^X(6![]~", "U");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(82, node0, 4095, 55);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05353() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(83, node0, 1, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05454() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(89, node0, 1, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05555() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.gogle.javascripl.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(91, node0, 38, (-2526));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05656() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(93, node0, 2, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05757() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(94, node0, 94, 37);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05858() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("A`8t&#h^X(6![]~", "com.google.javscript.jscomp.TypeInference$BooleanOtcomePkiM");
        Node node0 = compiler0.parse(sourceFile0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(96, node0, 4095, 55);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test05959() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(98, node0, 55, 4);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06060() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("=q/U1Jdpvv\u0001V{ZProx", "com.google.javascript.jscom.TypeInference$BoolenOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(104, node0, 2, 12);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06161() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javscript.jscomp.TypeInference$BooleanOtcomePkiM");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(106, node0, 37, 115);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06262() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?xco0lTrU!-Lrg", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(107, node0, (-397), (-3180));
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06363() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(108, node0, 688, 135);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06464() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        Scope scope0 = syntacticScopeCreator0.createScope(node0, (Scope) null);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = Node.newString(109, "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", 110, (-670));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06565() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(110, node0, (-722), 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06666() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(111, node0, 52, 2524);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06767() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(112, node0, 968, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06868() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.jvascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = Node.newString(113, "?C,>KPezoBsy", (-59), 39);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test06969() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(114, node0, 49, 42);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07070() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(115, node0, node0, node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07171() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("h;W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(116, node0, 15, 8);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07272() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Rw/T!8[/.Cga;4b7\"", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(117, node0, 57, 36);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07373() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(118, node0, 3439, 51);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07474() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(119, node0, 57, 3);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07575() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.gogle.javascripl.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(120, node0, 2, 49);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07676() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.TypeInference", "com.google.javascript.jscom.TypeInference$BoolenOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(121, node0, 1, 53);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07777() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function limeral argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(122, node0, 39, 41);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07878() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(123, node0, 51, 16);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test07979() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(124, node0, 29, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08080() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(125, node0, 127, 16);
        FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
        TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference1.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test08181() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(126, node0, 30, 1738);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08282() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(127, node0, 1614, 5804);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08383() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(128, node0, 137, (-2601));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08484() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(129, node0, 37, (-1211));
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08585() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(131, node0, 32, 2471);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08686() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.gogle.javascripl.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(133, node0, 2, 49);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08787() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(134, node0, 48, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08888() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W Ud1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(135, node0, 12, 32);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test08989() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(136, node0, 1, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09090() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("A`8t&#h^X(6![]~", "com.google.javscript.jscomp.TypeInference$BooleanOtcomePkiM");
        Node node0 = compiler0.parse(sourceFile0);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(137, node0, 4095, 55);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09191() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(138, "|*r*Rlbe\"=[}Vy0j", 2254, 53);
        ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09292() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(139, node0, 29, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09393() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(140, node0, 57, 957);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09494() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("com.google.javascript.jscomp.zypeInference$BooleanOutcomePair", "com.google.javascript.jscomp.zypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(141, node0, 50, 2);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09595() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(142, node0, 29, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09696() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.zypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(143, node0, 29, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09797() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(144, node0, 1, 3);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test09898() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(145, node0, 145, 30);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test09999() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(146, node0, 1601076620, (-1273));
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test100100() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(147, node0, 101, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test101101() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(148, "Object#Element", (-107), 55);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test102102() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(149, node0, 32, 29);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test103103() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(150, node0, 29, 1);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test104104() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.gogle.javascripl.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createGlobalScope(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(151, node0, 114, 31);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test105105() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(152, node0, 39, 2);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test106106() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(153, node0, 29, 0);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test107107() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode(";W d1", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        Scope scope0 = Scope.createLatticeBottom(node0);
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = new Node(154, node0, 37, 46);
        FlowScope flowScope0 = typeInference0.createEntryLattice();
        typeInference0.branchedFlowThrough(node1, flowScope0);
    }

    @Test(timeout = 4000)
    public void test108108() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = Node.newString(155, "Object#Key", 8, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test109109() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = Node.newString(1, "Object#Element", 53, 49);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test110110() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("Function literal argument refers to undefined this argument", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(130, node0, 36, 43);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test111111() throws Throwable {
        Compiler compiler0 = new Compiler();
        Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair");
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        Node node1 = Node.newString(4, "com.google.javascript.jsco;p.zypeInference$BooleanOutcomePair", 53, 4095);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test112112() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("_?Ico0lTrU!-Lme", "com.google.javascript.jscomp.TypeInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        ImmutableSortedMap<String, CodingConvention.AssertionFunctionSpec> immutableSortedMap0 = ImmutableSortedMap.of();
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, immutableSortedMap0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        Node node1 = new Node(37, node0, 57, 147);
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test113113() throws Throwable {
        Compiler compiler0 = new Compiler();
        SourceFile sourceFile0 = SourceFile.fromCode("4?Ico0lTrU!-Lre", "com.google.javascript.jscomp.TypnInference$BooleanOutcomePair");
        Node node0 = compiler0.parse(sourceFile0);
        ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
        JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
        Scope scope0 = Scope.createLatticeBottom(node0);
        TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, (Map<String, CodingConvention.AssertionFunctionSpec>) null);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
        Node node1 = new Node(63, node0, 51, 37);
        Node node2 = new Node(30, node1, 121, (-1538));
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    }

    @Test(timeout = 4000)
    public void test114114() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, true);
    }

    @Test(timeout = 4000)
    public void test115115() throws Throwable {
        BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.EMPTY;
        BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    }
}
