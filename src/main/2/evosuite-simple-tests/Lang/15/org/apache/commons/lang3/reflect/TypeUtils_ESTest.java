/*
 * This file was automatically generated by EvoSuite
 * Sun Apr 07 12:25:24 GMT 2024
 */
package org.apache.commons.lang3.reflect;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Map;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeUtils_ESTest extends TypeUtils_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test000() throws Throwable {
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn((Type) null).when(parameterizedType0).getRawType();
        // Undeclared exception!
        try {
            TypeUtils.getTypeArguments(parameterizedType0);
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            //
            // Wait... What!? Type of rawType: null
            //
            verifyException("org.apache.commons.lang3.reflect.TypeUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void test011() throws Throwable {
        Class<Object> class0 = Object.class;
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn(class0).when(parameterizedType0).getRawType();
        Class<String> class1 = String.class;
        Map<TypeVariable<?>, Type> map0 = TypeUtils.getTypeArguments((Type) parameterizedType0, (Class<?>) class1);
        assertNull(map0);
    }

    @Test(timeout = 4000)
    public void test022() throws Throwable {
        TypeUtils typeUtils0 = new TypeUtils();
    }

    @Test(timeout = 4000)
    public void test033() throws Throwable {
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        Type[] typeArray0 = new Type[9];
        typeArray0[0] = (Type) parameterizedType0;
        Type[] typeArray1 = TypeUtils.normalizeUpperBounds(typeArray0);
        assertEquals(1, typeArray1.length);
    }

    @Test(timeout = 4000)
    public void test044() throws Throwable {
        Type[] typeArray0 = new Type[6];
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        doReturn(typeArray0).when(wildcardType0).getLowerBounds();
        doReturn(typeArray0).when(wildcardType0).getUpperBounds();
        WildcardType wildcardType1 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        doReturn(typeArray0).when(wildcardType1).getLowerBounds();
        doReturn(typeArray0).when(wildcardType1).getUpperBounds();
        boolean boolean0 = TypeUtils.isAssignable(wildcardType1, wildcardType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test055() throws Throwable {
        Type type0 = mock(Type.class, new ViolatedAssumptionAnswer());
        doReturn("|u)iq<,*").when(type0).toString();
        // Undeclared exception!
        try {
            TypeUtils.isInstance(type0, type0);
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            //
            // found an unhandled type: |u)iq<,*
            //
            verifyException("org.apache.commons.lang3.reflect.TypeUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void test066() throws Throwable {
        Type[] typeArray0 = new Type[6];
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        doReturn(typeArray0).when(wildcardType0).getUpperBounds();
        Class<String> class0 = String.class;
        // Undeclared exception!
        try {
            TypeUtils.getTypeArguments((Type) wildcardType0, (Class<?>) class0);
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            //
            // found an unhandled type: null
            //
            verifyException("org.apache.commons.lang3.reflect.TypeUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void test077() throws Throwable {
        Class<Object> class0 = Object.class;
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn(class0).when(parameterizedType0).getRawType();
        boolean boolean0 = TypeUtils.isAssignable(parameterizedType0, class0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test088() throws Throwable {
        Type[] typeArray0 = new Type[8];
        Type type0 = mock(Type.class, new ViolatedAssumptionAnswer());
        doReturn((String) null).when(type0).toString();
        typeArray0[0] = type0;
        typeArray0[1] = type0;
        typeArray0[2] = type0;
        typeArray0[3] = type0;
        typeArray0[4] = type0;
        typeArray0[5] = type0;
        typeArray0[6] = type0;
        typeArray0[7] = type0;
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        doReturn(typeArray0).when(wildcardType0).getUpperBounds();
        Class<String> class0 = String.class;
        // Undeclared exception!
        try {
            TypeUtils.getTypeArguments((Type) wildcardType0, (Class<?>) class0);
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            //
            // found an unhandled type: null
            //
            verifyException("org.apache.commons.lang3.reflect.TypeUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void test099() throws Throwable {
        Class<Object> class0 = Object.class;
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn(class0).when(parameterizedType0).getRawType();
        boolean boolean0 = TypeUtils.isInstance(class0, parameterizedType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test1010() throws Throwable {
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        boolean boolean0 = TypeUtils.isAssignable(parameterizedType0, parameterizedType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test1111() throws Throwable {
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        Type[] typeArray0 = new Type[5];
        typeArray0[0] = (Type) wildcardType0;
        Type[] typeArray1 = TypeUtils.normalizeUpperBounds(typeArray0);
        assertEquals(1, typeArray1.length);
    }

    @Test(timeout = 4000)
    public void test1212() throws Throwable {
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        boolean boolean0 = TypeUtils.isAssignable(wildcardType0, wildcardType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test1313() throws Throwable {
        Type[] typeArray0 = new Type[1];
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        doReturn(typeArray0).when(wildcardType0).getLowerBounds();
        doReturn(typeArray0).when(wildcardType0).getUpperBounds();
        boolean boolean0 = TypeUtils.isInstance(wildcardType0, wildcardType0);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test1414() throws Throwable {
        Class<Object> class0 = Object.class;
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn((Type[]) null).when(parameterizedType0).getActualTypeArguments();
        doReturn(class0).when(parameterizedType0).getOwnerType();
        doReturn(class0, class0).when(parameterizedType0).getRawType();
        Map<TypeVariable<?>, Type> map0 = TypeUtils.determineTypeArguments(class0, parameterizedType0);
        assertTrue(map0.isEmpty());
    }

    @Test(timeout = 4000)
    public void test1515() throws Throwable {
        Class<String> class0 = String.class;
        Class<Object> class1 = Object.class;
        Type[] typeArray0 = new Type[3];
        typeArray0[0] = (Type) class0;
        Class<?> class2 = TypeUtils.getRawType(class1, typeArray0[1]);
        typeArray0[2] = (Type) class2;
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn(typeArray0).when(parameterizedType0).getActualTypeArguments();
        doReturn(class2).when(parameterizedType0).getOwnerType();
        doReturn(class1, typeArray0[2], typeArray0[0]).when(parameterizedType0).getRawType();
        Map<TypeVariable<?>, Type> map0 = TypeUtils.determineTypeArguments(class0, parameterizedType0);
        assertEquals(0, map0.size());
    }

    @Test(timeout = 4000)
    public void test1616() throws Throwable {
        Class<String> class0 = String.class;
        Map<TypeVariable<?>, Type> map0 = TypeUtils.getTypeArguments((Type) class0, (Class<?>) null);
        assertNull(map0);
    }

    @Test(timeout = 4000)
    public void test1717() throws Throwable {
        Class<String> class0 = String.class;
        Class<Object> class1 = Object.class;
        Map<TypeVariable<?>, Type> map0 = TypeUtils.getTypeArguments((Type) class0, (Class<?>) class1);
        assertTrue(map0.isEmpty());
    }

    @Test(timeout = 4000)
    public void test1818() throws Throwable {
        Class<String> class0 = String.class;
        Class<Object> class1 = Object.class;
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn(class0).when(parameterizedType0).getRawType();
        Map<TypeVariable<?>, Type> map0 = TypeUtils.determineTypeArguments(class1, parameterizedType0);
        assertNull(map0);
    }

    @Test(timeout = 4000)
    public void test1919() throws Throwable {
        boolean boolean0 = TypeUtils.isInstance((Object) null, (Type) null);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test2020() throws Throwable {
        Class<Object> class0 = Object.class;
        boolean boolean0 = TypeUtils.isInstance((Object) null, class0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test2121() throws Throwable {
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        boolean boolean0 = TypeUtils.isInstance((Object) null, parameterizedType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test2222() throws Throwable {
        Class<String> class0 = String.class;
        Map<TypeVariable<?>, Type> map0 = TypeUtils.getTypeArguments((Type) class0, (Class<?>) class0);
        assertNotNull(map0);
    }

    @Test(timeout = 4000)
    public void test2223() throws Throwable {
        Class<String> class0 = String.class;
        Map<TypeVariable<?>, Type> map0 = TypeUtils.getTypeArguments((Type) class0, (Class<?>) class0);
        boolean boolean0 = TypeUtils.typesSatisfyVariables(map0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test2324() throws Throwable {
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        Class<?> class0 = TypeUtils.getRawType(wildcardType0, (Type) null);
        assertNull(class0);
    }

    @Test(timeout = 4000)
    public void test2425() throws Throwable {
        ParameterizedType parameterizedType0 = mock(ParameterizedType.class, new ViolatedAssumptionAnswer());
        doReturn((Type) null).when(parameterizedType0).getRawType();
        // Undeclared exception!
        try {
            TypeUtils.getRawType(parameterizedType0, parameterizedType0);
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            //
            // Wait... What!? Type of rawType: null
            //
            verifyException("org.apache.commons.lang3.reflect.TypeUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void test2526() throws Throwable {
        // Undeclared exception!
        try {
            TypeUtils.getRawType((Type) null, (Type) null);
            fail("Expecting exception: IllegalArgumentException");
        } catch (IllegalArgumentException e) {
            //
            // unknown type: null
            //
            verifyException("org.apache.commons.lang3.reflect.TypeUtils", e);
        }
    }

    @Test(timeout = 4000)
    public void test2627() throws Throwable {
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        boolean boolean0 = TypeUtils.isArrayType(wildcardType0);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test2728() throws Throwable {
        Class<Object> class0 = Object.class;
        boolean boolean0 = TypeUtils.isArrayType(class0);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test2829() throws Throwable {
        WildcardType wildcardType0 = mock(WildcardType.class, new ViolatedAssumptionAnswer());
        Type type0 = TypeUtils.getArrayComponentType(wildcardType0);
        assertNull(type0);
    }

    @Test(timeout = 4000)
    public void test2930() throws Throwable {
        Class<Object> class0 = Object.class;
        Type type0 = TypeUtils.getArrayComponentType(class0);
        assertNull(type0);
    }
}
