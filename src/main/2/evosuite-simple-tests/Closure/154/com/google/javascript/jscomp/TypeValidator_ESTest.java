/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 09:43:22 GMT 2024
 */
package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.ImmutableSortedSet;
import com.google.javascript.jscomp.AbstractCompiler;
import com.google.javascript.jscomp.AbstractPeepholeOptimization;
import com.google.javascript.jscomp.CheckAccessControls;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.DeadAssignmentsElimination;
import com.google.javascript.jscomp.DefaultCodingConvention;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.LineNumberCheck;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.MakeDeclaredNamesUnique;
import com.google.javascript.jscomp.NameReferenceGraph;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.PeepholeOptimizationsPass;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeValidator;
import com.google.javascript.jscomp.UnfoldCompoundAssignments;
import com.google.javascript.rhino.ErrorReporter;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.EnumElementType;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NoType;
import com.google.javascript.rhino.jstype.ObjectType;
import java.io.File;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true)
public class TypeValidator_ESTest extends TypeValidator_ESTest_scaffolding {

    @Test(timeout = 4000)
    public void test000() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Iterable<TypeValidator.TypeMismatch> iterable0 = typeValidator0.getMismatches();
        assertNotNull(iterable0);
    }

    @Test(timeout = 4000)
    public void test011() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType0, objectType0);
        String string0 = typeValidator_TypeMismatch0.toString();
        assertEquals("({}, {})", string0);
    }

    @Test(timeout = 4000)
    public void test022() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = new Node(0);
        boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, objectType0, "Not declared as a type name");
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test033() throws Throwable {
        Compiler compiler0 = new Compiler();
        MockFile mockFile0 = new MockFile("");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile((File) mockFile0, (Charset) null);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ArrayList<JSType> arrayList0 = new ArrayList<JSType>();
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) arrayList0);
        JSType[] jSTypeArray0 = new JSType[1];
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        jSTypeArray0[0] = jSType0;
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0, syntacticScopeCreator0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Gf'h`c2Q8eQ", jSTypeArray0[0]);
        typeValidator0.expectActualObject(nodeTraversal0, node0, enumType0, "Unknown class name");
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test044() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        Node node0 = compiler0.jsRoot;
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, lineNumberCheck0);
        JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(objectType0);
        typeValidator0.expectActualObject(nodeTraversal0, node0, jSType0, "5*)Sv");
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test055() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        typeValidator0.expectAnyObject(nodeTraversal0, (Node) null, objectType0, "Unknown class name");
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test066() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "");
        typeValidator0.expectAnyObject(nodeTraversal0, (Node) null, noType0, "Not declared as a type name");
        assertTrue(noType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test067() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "");
        typeValidator0.expectAnyObject(nodeTraversal0, (Node) null, noType0, "Not declared as a type name");
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test078() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "Not declared as a type name");
        CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
        JSType jSType1 = jSTypeRegistry0.createDefaultObjectUnion(jSType0);
        typeValidator0.expectAnyObject(nodeTraversal0, (Node) null, jSType1, "Named type with empty name component");
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test089() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Unknown class name", objectType0);
        typeValidator0.expectIndexMatch(nodeTraversal0, (Node) null, objectType0, enumType0);
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test0910() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = Node.newString((-844), "]C2PnFE2qW", 80, (-844));
        NameReferenceGraph nameReferenceGraph0 = new NameReferenceGraph(compiler0);
        NameReferenceGraph.Name nameReferenceGraph_Name0 = nameReferenceGraph0.defineNameIfNotExists("{-z[`FZd", true);
        JSType jSType0 = nameReferenceGraph_Name0.getType();
        typeValidator0.expectNumber(nodeTraversal0, node0, jSType0, "assignment to property ");
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test1011() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
        DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
        ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
        JSTypeNative jSTypeNative0 = JSTypeNative.TOP_LEVEL_PROTOTYPE;
        JSType jSType0 = closureReverseAbstractInterpreter0.getNativeType(jSTypeNative0);
        JSType jSType1 = jSTypeRegistry0.createNullableType(jSType0);
        typeValidator0.expectBitwiseable(nodeTraversal0, (Node) null, jSType1, "function");
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test1112() throws Throwable {
        Compiler compiler0 = new Compiler();
        MockFile mockFile0 = new MockFile("");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile((File) mockFile0, (Charset) null);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0);
        Node node0 = new Node(2155);
        Scope scope0 = new Scope(node0, compiler0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        JSType jSType0 = linkedFlowScope0.getTypeOfThis();
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, "");
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test1213() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = new Node(1);
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, objectType0, "Not declared as a constructor");
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test1214() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = new Node(1);
        typeValidator0.expectBitwiseable(nodeTraversal0, node0, objectType0, "Not declared as a constructor");
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test1315() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        Node node0 = nodeTraversal0.getEnclosingFunction();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSType jSType0 = jSTypeRegistry0.createNamedType("", "", 11, 31);
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
        assertFalse(jSType0.isConstructor());
    }

    @Test(timeout = 4000)
    public void test1416() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, objectType0, "Not declared as a constructor");
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test1417() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, objectType0, "Not declared as a constructor");
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test1518() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = new Node(1);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", objectType0);
        EnumElementType enumElementType0 = enumType0.getElementsType();
        JSType jSType0 = enumElementType0.getPropertyType("Not declared as a constructor");
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, enumType0);
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test1619() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "");
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, (Node) null, jSType0, "", jSType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test1720() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, (Node) null, objectType0, "n*x+2HhFpwU,ZSk", objectType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test1821() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSType jSType0 = jSTypeRegistry0.createNamedType("Unknown class name", "Named type with empty name component", 31, 8203);
        boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, (Node) null, jSType0, "n*x+2HhFpwU,ZSk", objectType0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test1922() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = new Node(0, 1, 0);
        typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, objectType0, objectType0);
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test2023() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        FunctionType functionType0 = jSTypeRegistry0.createInterfaceType("Unknown class name", (Node) null);
        // Undeclared exception!
        try {
            typeValidator0.expectSwitchMatchesCase(nodeTraversal0, (Node) null, functionType0, objectType0);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test2124() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
        ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = new Node(1, 0, (-9));
        typeValidator0.expectIndexMatch(nodeTraversal0, node0, objectType0, objectType0);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test2225() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[2];
        JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
        jSTypeNativeArray0[0] = jSTypeNative0;
        jSTypeNativeArray0[1] = jSTypeNative0;
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        typeValidator0.expectIndexMatch(nodeTraversal0, (Node) null, jSType0, objectType0);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test2326() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, (String) null);
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, (Node) null, objectType0, jSType0, (Node) null, "Not declared as a constructor");
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test2427() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, (Node) null, objectType0, objectType0, (Node) null, "Unknown class name");
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test2528() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ObjectType objectType1 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        // Undeclared exception!
        try {
            typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, (Node) null, objectType0, objectType1, (Node) null, "Unknown class name");
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test2629() throws Throwable {
        Compiler compiler0 = new Compiler();
        MockFile mockFile0 = new MockFile("");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile((File) mockFile0, (Charset) null);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ArrayList<JSType> arrayList0 = new ArrayList<JSType>();
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) arrayList0);
        JSType[] jSTypeArray0 = new JSType[1];
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, jSTypeArray0);
        jSTypeArray0[0] = (JSType) functionType0;
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0, syntacticScopeCreator0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Gf'h`c2Q8eQ", jSTypeArray0[0]);
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType0, functionType0, node0, "");
        assertTrue(functionType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test2630() throws Throwable {
        Compiler compiler0 = new Compiler();
        MockFile mockFile0 = new MockFile("");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile((File) mockFile0, (Charset) null);
        CompilerOptions compilerOptions0 = new CompilerOptions();
        compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        MakeDeclaredNamesUnique makeDeclaredNamesUnique0 = new MakeDeclaredNamesUnique();
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ArrayList<JSType> arrayList0 = new ArrayList<JSType>();
        Node node0 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) arrayList0);
        JSType[] jSTypeArray0 = new JSType[1];
        JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
        JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, jSTypeArray0);
        jSTypeArray0[0] = (JSType) functionType0;
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, makeDeclaredNamesUnique0, syntacticScopeCreator0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Gf'h`c2Q8eQ", jSTypeArray0[0]);
        boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType0, functionType0, node0, "");
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test2731() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, objectType0, objectType0, "Nx\"_~VeND");
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test2832() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[2];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(functionType0, "Named type with empty name component");
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, functionType0, noType0, "/1Z,yA}zj!");
        assertTrue(noType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test2833() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[2];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(functionType0, "Named type with empty name component");
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, functionType0, noType0, "/1Z,yA}zj!");
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test2934() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        DeadAssignmentsElimination deadAssignmentsElimination0 = new DeadAssignmentsElimination(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, deadAssignmentsElimination0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "Class {0} has been deprecated: {1}");
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, objectType0, noType0, "Named type with empty name component");
        assertTrue(noType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test2935() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        DeadAssignmentsElimination deadAssignmentsElimination0 = new DeadAssignmentsElimination(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, deadAssignmentsElimination0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "Class {0} has been deprecated: {1}");
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, objectType0, noType0, "Named type with empty name component");
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test3036() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        FunctionType functionType0 = jSTypeRegistry0.createInterfaceType("Unknown class name", (Node) null);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Named type with empty name component", objectType0);
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, functionType0, enumType0, "Unknown class name");
        assertTrue(functionType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test3037() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        FunctionType functionType0 = jSTypeRegistry0.createInterfaceType("Unknown class name", (Node) null);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Named type with empty name component", objectType0);
        boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, (Node) null, functionType0, enumType0, "Unknown class name");
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test3138() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, (Node) null, objectType0, objectType0, (Node) null, 0);
        assertEquals(BooleanLiteralSet.TRUE, objectType0.getPossibleToBooleanOutcomes());
    }

    @Test(timeout = 4000)
    public void test3239() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[2];
        jSTypeArray0[1] = (JSType) objectType0;
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        // Undeclared exception!
        try {
            typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, (Node) null, jSTypeArray0[1], functionType0, (Node) null, 7);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test3340() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType jSType0 = jSTypeRegistry0.getGreatestSubtypeWithProperty(objectType0, "Not declared as a type name");
        CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkAccessControls0);
        JSType jSType1 = jSTypeRegistry0.createDefaultObjectUnion(jSType0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, jSType1, jSType1, "com.google.protobuf.DescriptorProtos", jSType0);
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test3441() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        typeValidator0.setShouldReport(false);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Vector<JSType> vector0 = new Vector<JSType>();
        JSType[] jSTypeArray0 = new JSType[3];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) vector0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, functionType1, "Named type with empty name component", jSTypeArray0[1]);
        assertTrue(functionType1.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test3442() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        typeValidator0.setShouldReport(false);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Vector<JSType> vector0 = new Vector<JSType>();
        JSType[] jSTypeArray0 = new JSType[3];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) vector0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, functionType1, "Named type with empty name component", jSTypeArray0[1]);
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test3543() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ImmutableSortedSet<AbstractPeepholeOptimization> immutableSortedSet0 = ImmutableSortedSet.of();
        PeepholeOptimizationsPass peepholeOptimizationsPass0 = new PeepholeOptimizationsPass(compiler0, immutableSortedSet0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, peepholeOptimizationsPass0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", objectType0);
        ObjectType objectType1 = enumType0.getImplicitPrototype();
        ObjectType objectType2 = jSTypeRegistry0.createObjectType(objectType0);
        typeValidator0.expectSuperType(nodeTraversal0, (Node) null, objectType1, objectType2);
        assertEquals(0, nodeTraversal0.getLineNumber());
    }

    @Test(timeout = 4000)
    public void test3644() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ObjectType objectType1 = jSTypeRegistry0.createObjectType(objectType0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = Node.newString(1, "Not declared as a type name", 0, 1);
        // Undeclared exception!
        try {
            typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType1);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test3745() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        typeValidator0.setShouldReport(false);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ObjectType objectType1 = jSTypeRegistry0.createObjectType(objectType0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        // Undeclared exception!
        try {
            typeValidator0.expectSuperType(nodeTraversal0, (Node) null, objectType0, objectType1);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test3846() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", objectType0);
        ObjectType objectType1 = enumType0.getImplicitPrototype();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType1);
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test3847() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", objectType0);
        ObjectType objectType1 = enumType0.getImplicitPrototype();
        Node node0 = compiler0.parseTestCode("Not declared as a type name");
        typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType1);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test3948() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = compiler0.parseTestCode("Named type with empty name component");
        typeValidator0.expectCanCast(nodeTraversal0, node0, objectType0, objectType0);
        assertEquals((-1), node0.getLineno());
    }

    @Test(timeout = 4000)
    public void test4049() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[2];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        typeValidator0.expectCanCast(nodeTraversal0, (Node) null, objectType0, functionType0);
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test4050() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[2];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        typeValidator0.expectCanCast(nodeTraversal0, (Node) null, objectType0, functionType0);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test4151() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ObjectType objectType1 = jSTypeRegistry0.createObjectType("Named type with empty name component", (Node) null, objectType0);
        SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, syntacticScopeCreator0);
        typeValidator0.expectCanCast(nodeTraversal0, (Node) null, objectType0, objectType1);
        assertTrue(objectType1.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test4252() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        typeValidator0.setShouldReport(false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ObjectType objectType1 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = compiler0.parseTestCode("Not declared as a constructor");
        typeValidator0.expectCanCast(nodeTraversal0, node0, objectType1, objectType0);
        assertTrue(objectType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test4253() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        typeValidator0.setShouldReport(false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        ObjectType objectType1 = jSTypeRegistry0.createAnonymousObjectType();
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        Node node0 = compiler0.parseTestCode("Not declared as a constructor");
        typeValidator0.expectCanCast(nodeTraversal0, node0, objectType1, objectType0);
        assertTrue(objectType1.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test4354() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = new Node(118, 1, 0);
        Scope scope0 = new Scope(node0, objectType0);
        Scope.Var scope_Var0 = scope0.declare("Not declared as a type name", node0, objectType0, (CompilerInput) null);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        typeValidator0.expectUndeclaredVariable("condition always evaluates to the same value\nleft : {0}\nright: {1}", node0, node0, scope_Var0, "03M)e,bQ|D#", objectType0);
        String string0 = typeValidator0.getReadableJSTypeName(node0, true);
        assertNotNull(string0);
    }

    @Test(timeout = 4000)
    public void test4455() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = Node.newString(1, "Named type with empty name component");
        Node node1 = new Node(33, node0, node0, node0, node0, 40, 39);
        // Undeclared exception!
        try {
            typeValidator0.expectUndeclaredVariable("Not declared as a type name", node1, node1, (Scope.Var) null, "Not declared as a type name", objectType0);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test4556() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = Node.newString(1, "Named type with empty name component");
        Node node1 = new Node(33, node0, node0, node0, node0, 40, 39);
        node1.addSuppression("Not declared as a constructor");
        // Undeclared exception!
        try {
            typeValidator0.expectUndeclaredVariable("Not declared as a type name", node1, node1, (Scope.Var) null, "Not declared as a type name", objectType0);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.javascript.jscomp.TypeValidator", e);
        }
    }

    @Test(timeout = 4000)
    public void test4657() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = Node.newString(1, "Named type with empty name component");
        Scope scope0 = new Scope(node0, objectType0);
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Not declared as a constructor");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0);
        Scope.Var scope_Var0 = scope0.declare("ib5", node0, (JSType) null, compilerInput0, false);
        typeValidator0.expectUndeclaredVariable("Named type with empty name component", node0, node0, scope_Var0, "Unknown class name", objectType0);
        assertFalse(objectType0.isBooleanValueType());
    }

    @Test(timeout = 4000)
    public void test4758() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node0 = new Node(3036, 3036, 15);
        Scope scope0 = new Scope(node0, compiler0);
        MockFile mockFile0 = new MockFile("$4~N6Q^Vg)1$cnIHesJ");
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile((File) mockFile0);
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0);
        SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
        LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
        JSType jSType0 = linkedFlowScope0.getTypeOfThis();
        ObjectType objectType0 = ObjectType.cast(jSType0);
        EnumType enumType0 = jSTypeRegistry0.createEnumType("$4~N6Q^Vg)1$cnIHesJ", objectType0);
        EnumElementType enumElementType0 = enumType0.getElementsType();
        JSType jSType1 = enumElementType0.getPropertyType("QtPNOj0SO+@");
        Scope.Var scope_Var0 = scope0.declare("$4~N6Q^Vg)1$cnIHesJ", node0, jSType1, compilerInput0, true);
        typeValidator0.expectUndeclaredVariable("Named type with empty name component", node0, node0, scope_Var0, "variable {0} redefined with type {1}, original definition at {2}:{3} with type {4}", enumElementType0);
        assertEquals(2, Node.BREAK_PROP);
    }

    @Test(timeout = 4000)
    public void test4859() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = new Node(1);
        Scope scope0 = new Scope(node0, (ObjectType) null);
        Scope.Var scope_Var0 = scope0.declare("Not declared as a type name", node0, objectType0, (CompilerInput) null);
        typeValidator0.expectUndeclaredVariable((String) null, node0, node0, scope_Var0, "Can't remove external name-only definition", (JSType) null);
        assertFalse(node0.hasMoreThanOneChild());
    }

    @Test(timeout = 4000)
    public void test4960() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = new Node(1);
        Scope scope0 = new Scope(node0, objectType0);
        Scope.Var scope_Var0 = scope0.declare("TightenTypes pass appears to be stuck in an infinite loop.", node0, objectType0, (CompilerInput) null);
        TypeValidator typeValidator0 = new TypeValidator(compiler0);
        // Undeclared exception!
        try {
            typeValidator0.expectUndeclaredVariable("TightenTypes pass appears to be stuck in an infinite loop.", node0, node0, scope_Var0, "Named type with empty name component", objectType0);
            fail("Expecting exception: IllegalStateException");
        } catch (IllegalStateException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("com.google.common.base.Preconditions", e);
        }
    }

    @Test(timeout = 4000)
    public void test5061() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TightenTypes tightenTypes0 = new TightenTypes(compiler0);
        JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = new Node(118, 1, 0);
        Scope scope0 = new Scope(node0, objectType0);
        Scope.Var scope_Var0 = scope0.declare("Not declared as a type name", node0, objectType0, (CompilerInput) null);
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(12, node0, node0, node0);
        typeValidator0.expectUndeclaredVariable(" <rN0#c=X{T4a[X|aJm", node1, node0, scope_Var0, "", objectType0);
        assertEquals(27, Node.SPECIALCALL_PROP);
    }

    @Test(timeout = 4000)
    public void test5162() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = Node.newString(0, "Named type with empty name component");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(170, node0, node0, node0, node0, 4, (-1009));
        Scope scope0 = new Scope(node0, compiler0);
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Not declared as a constructor");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
        Scope.Var scope_Var0 = scope0.declare("Unknown class name", node0, objectType0, compilerInput0, true);
        typeValidator0.expectUndeclaredVariable("0hi=rF.0an4", node0, node0, scope_Var0, "Not declared as a type name", objectType0);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test5263() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Node node0 = Node.newString(0, "Named type with empty name component");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node1 = new Node(170, node0, node0, node0, node0, 4, (-1009));
        Scope scope0 = new Scope(node0, compiler0);
        JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Not declared as a constructor");
        CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
        Scope.Var scope_Var0 = scope0.declare("Unknown class name", node0, objectType0, compilerInput0, true);
        typeValidator0.setShouldReport(false);
        typeValidator0.expectUndeclaredVariable("0hi=rF.0an4", node0, node0, scope_Var0, "Not declared as a type name", objectType0);
        assertEquals(4, Node.DESCENDANTS_FLAG);
    }

    @Test(timeout = 4000)
    public void test5364() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[2];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        NoType noType0 = (NoType) jSTypeRegistry0.getGreatestSubtypeWithProperty(functionType0, "Named type with empty name component");
        typeValidator0.expectAllInterfaceProperties(nodeTraversal0, (Node) null, noType0);
        assertTrue(noType0.isNullable());
    }

    @Test(timeout = 4000)
    public void test5465() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        typeValidator0.setShouldReport(false);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        typeValidator0.expectIndexMatch(nodeTraversal0, (Node) null, objectType0, objectType0);
        assertEquals(0, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test5566() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[3];
        FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) objectType0, (Node) null);
        FunctionType functionType1 = jSTypeRegistry0.createConstructorType((JSType) functionType0, jSTypeArray0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, functionType1, "Named type with empty name component", functionType0);
        assertTrue(functionType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test5567() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSType[] jSTypeArray0 = new JSType[3];
        FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) objectType0, (Node) null);
        FunctionType functionType1 = jSTypeRegistry0.createConstructorType((JSType) functionType0, jSTypeArray0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, functionType1, "Named type with empty name component", functionType0);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test5668() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0, (ScopeCreator) null);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        Vector<JSType> vector0 = new Vector<JSType>();
        vector0.add((JSType) objectType0);
        JSType[] jSTypeArray0 = new JSType[3];
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        FunctionType functionType1 = jSTypeRegistry0.createFunctionType((JSType) functionType0, (List<JSType>) vector0);
        // Undeclared exception!
        try {
            typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, functionType1, "Named type with empty name component", jSTypeArray0[1]);
            fail("Expecting exception: NullPointerException");
        } catch (NullPointerException e) {
            //
            // no message in exception (getMessage() returned null)
            //
            verifyException("org.evosuite.runtime.System", e);
        }
    }

    @Test(timeout = 4000)
    public void test5769() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
        JSType[] jSTypeArray0 = new JSType[4];
        jSTypeArray0[0] = (JSType) objectType0;
        jSTypeArray0[1] = (JSType) objectType0;
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, jSTypeArray0[1], "Not declared as a constructor", jSTypeArray0[1]);
        assertEquals(1, compiler0.getWarningCount());
    }

    @Test(timeout = 4000)
    public void test5770() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        LineNumberCheck lineNumberCheck0 = new LineNumberCheck(compiler0);
        NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, lineNumberCheck0);
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
        JSType[] jSTypeArray0 = new JSType[4];
        jSTypeArray0[0] = (JSType) objectType0;
        jSTypeArray0[1] = (JSType) objectType0;
        FunctionType functionType0 = jSTypeRegistry0.createConstructorType((JSType) objectType0, jSTypeArray0);
        typeValidator0.expectCanOverride(nodeTraversal0, (Node) null, functionType0, jSTypeArray0[1], "Not declared as a constructor", jSTypeArray0[1]);
        assertTrue(functionType0.hasCachedValues());
    }

    @Test(timeout = 4000)
    public void test5871() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node0 = Node.newString(1, "Named type with empty name component");
        Node node1 = new Node(33, node0, node0, node0, node0, 2, 39);
        String string0 = typeValidator0.getReadableJSTypeName(node1, true);
        assertNotNull(string0);
    }

    @Test(timeout = 4000)
    public void test5972() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        Node node0 = Node.newString(0, "Named type with empty name component");
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        String string0 = typeValidator0.getReadableJSTypeName(node0, false);
        assertNotNull(string0);
    }

    @Test(timeout = 4000)
    public void test6073() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        TypeValidator typeValidator0 = compiler0.getTypeValidator();
        Node node0 = Node.newString(1, "Named type with empty name component");
        Node node1 = new Node(42, node0, node0, node0, node0, 2, 39);
        String string0 = typeValidator0.getReadableJSTypeName(node1, false);
        assertEquals("this", string0);
    }

    @Test(timeout = 4000)
    public void test6174() throws Throwable {
        JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType0, objectType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(objectType0);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test6275() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
        ObjectType objectType1 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType1, objectType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch0);
        assertTrue(boolean0);
    }

    @Test(timeout = 4000)
    public void test6376() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        ObjectType objectType1 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType0, objectType0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(objectType0, objectType1);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test6377() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        ObjectType objectType1 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType0, objectType0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(objectType0, objectType1);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
        assertFalse(typeValidator_TypeMismatch1.equals((Object) typeValidator_TypeMismatch0));
    }

    @Test(timeout = 4000)
    public void test6478() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType0, functionType0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(functionType0, (JSType) null);
        boolean boolean0 = typeValidator_TypeMismatch1.equals(typeValidator_TypeMismatch0);
        assertFalse(boolean0);
    }

    @Test(timeout = 4000)
    public void test6579() throws Throwable {
        Compiler compiler0 = new Compiler();
        compiler0.getErrorManager();
        JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
        ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
        JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
        FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(objectType0, functionType0);
        TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(functionType0, objectType0);
        boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
        assertTrue(boolean0);
    }
}
