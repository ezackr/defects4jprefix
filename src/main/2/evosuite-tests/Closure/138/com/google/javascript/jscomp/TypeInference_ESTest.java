/*
 * This file was automatically generated by EvoSuite
 * Sat Apr 06 08:29:38 GMT 2024
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.Multimap;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.ControlFlowGraph;
import com.google.javascript.jscomp.FlowScope;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.LinkedFlowScope;
import com.google.javascript.jscomp.LoggerErrorManager;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.TightenTypes;
import com.google.javascript.jscomp.TypeInference;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.BooleanLiteralSet;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NamedType;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.TreeSet;
import java.util.logging.Logger;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeInference_ESTest extends TypeInference_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
      Node node1 = new Node(101, node0, node0, node0, 126, 49);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // AND 126 : com.google.javascript.rhino.jstype.StringType@0000000042 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(86, 102, (-25));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("c-Q~~x !Sa~afZ#+?", 0, (-587));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, linkedList0);
      Node node1 = Node.newString(63, "msg.no.brace.switch", 0, 10);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("", 3605, (-516));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(100, "");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, flowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE", 0, 1479);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Multimap<Scope, Scope.Var> multimap0 = typeInference0.getAssignedOuterLocalVars();
      assertNotNull(multimap0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 1034);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(33);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Logger logger0 = Logger.getLogger(":reur");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("N]=eal4>s,H", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      linkedList0.addLast((Scope.Var) null);
      TypeInference typeInference0 = null;
      try {
        typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
      Node node1 = new Node(4, node0, node0, node0, 4095, 7);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      Node node1 = Node.newString(5, "");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GOTO  does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Logger logger0 = Logger.getLogger(":reur");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode(":reur");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(6, (-2704), 115);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
      Node node1 = new Node(7, node0, node0, node0, 4, 2301);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("", 3605, (-516));
      Node node1 = new Node(8, node0, node0, node0, 40, 7);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1598));
      Node node1 = new Node(9, node0, node0, 34, (-2));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITOR : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      Node node1 = new Node(11, node0, node0, node0, 44, (-776));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      Node node1 = Node.newString(12, "com.googlecommoncollect.AbstractSetMultimap", 4095, 1);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EQ com.googlecommoncollect.AbstractSetMultimap 4095 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("c-Q~~ !Sa~afZ#+?", 1249, 1249);
      Node node1 = new Node(13, node0, node0, node0, 1498, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NE 1498 : com.google.javascript.rhino.jstype.BooleanType@0000000042 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(14);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(130, "j[hkC8g5[UQSK/", 0, 38);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(15, "j[hkC8g5[UQSK/");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE", 0, 1479);
      Node node1 = new Node(16, node0, node0, node0, (-582), 12);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GT : com.google.javascript.rhino.jstype.BooleanType@0000000042 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("c-Q~ !SAa~af#+?", 0, 0);
      Node node1 = Node.newString(17, "c-Q~ !SAa~af#+?");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // GE c-Q~ !SAa~af#+? : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      Node node1 = Node.newString(18, "\"T|*o9@Q");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LSH \"T|*o9@Q : com.google.javascript.rhino.jstype.NumberType@0000000047 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("c-Q~~ !Sa~afZ#+?", 0, (-587));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(19, "");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("c-Q~~ !Sa~afZ#+?", 1249, 1249);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(20, "com.google.javascript.jscomp.NameReferenceGraph$Name");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // URSH com.google.javascript.jscomp.NameReferenceGraph$Name : com.google.javascript.rhino.jstype.NumberType@0000000044 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("wc.MP^5nK.NR%o-", 0, (-587));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createScope(node0, (Scope) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(21, node0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 3227, 117);
      Node node1 = new Node(22, node0, node0, node0, 3, 4095);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("c-Q~ !SAa~af#+?", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(23, "&Smkw*0q-t,$G");
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("wc.MP^5nK.NR%o-", 1364, 1364);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = Node.newString(24, "&Smkw*0q-t,$G");
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DIV &Smkw*0q-t,$G : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1598));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(25);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
      Node node1 = new Node(26, node0, node0, node0, 47, 48);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NOT 47 : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
      Node node1 = new Node(27, node0, 2, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // BITNOT 2 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("wc.MP^5nK.NR%o-", 1364, 1364);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = Node.newString(28, "wc.MP^5nK.NR%o-");
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
      Node node1 = Node.newString(29, "com.googlecommoncollect.AbstractSetMultimap", 1, 130);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("wc.MP^5nK.NR%o-", 1364, 1364);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(30, 77, 35);
      // Undeclared exception!
      try { 
        typeInference0.flowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("", 0, (-587));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(31, "", 41, 952);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DELPROP  41 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultim}p");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
      node0.setType(32);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Logger logger0 = Logger.getLogger(":rePr");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode(":rePr");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(34, ":rePr", 15, 809);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      Logger logger0 = Logger.getLogger(":reur");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode(":reur");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(36, 15, 30);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // SETELEM 15 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newNumber((-1500.8320871930864), 123, 123);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      NamedType namedType0 = new NamedType(jSTypeRegistry0, "fvq#N@lGxz", (String) null, (-5135), 0);
      Scope scope0 = new Scope(node0, namedType0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0);
      FlowScope flowScope0 = typeInference1.createInitialEstimateLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 0, 0);
      Node node1 = new Node(41, node0, node0, node0, 2157, 710);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NULL 2157 : com.google.javascript.rhino.jstype.NullType@0000000040 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      node0.setType(42);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.LinkedFlowScope", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, priorityQueue0);
      Node node1 = Node.newString(43, "");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("W7e4/lv>i)k{u/7Hs5", (-600), (-600));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(44);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(45, 27, 28);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, codingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, linkedList0);
      node0.setType(46);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("41etrn", (-19), (-19));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(47, 16, (-24));
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // OBJECT : com.google.javascript.rhino.jstype.InstanceObjectType@0000000206 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      Node node1 = Node.newString(48, "\"T|*o9@Q", (-3547), (-2392));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("", 3605, (-516));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(51, "Cannot read: {0}");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IN Cannot read: {0} : com.google.javascript.rhino.jstype.BooleanType@0000000039 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      Logger logger0 = Logger.getLogger(":reur");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode(":reur");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = Node.newString(53, "TightenTypes pass appears to be stuck in an infinite loop.");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%o-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("inlineConstants", 1249, 1249);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      Node node1 = new Node(58, 1249, 83);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(70);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      Logger logger0 = Logger.getGlobal();
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("c-Q~~x !Sa~afZ#+?", 0, (-587));
      Node node1 = new Node(72, node0, node0, node0, 1, 40);
      Node node2 = new Node(49, node1, node1, node1, 12, 26);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(2883);
      Node node1 = new Node(74, node0, node0, node0, 950, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // REF_NS_MEMBER 950 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
      node0.setType(83);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("", 3582, (-516));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(84, "");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      node0.setType(85);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(89);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1590));
      Node node1 = Node.newString(90, "");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, hashSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_LSH  : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      Logger logger0 = Logger.getLogger("wc.MP^5nK.NR%oo-");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = Node.newString("c-Q~ !SAa~af#+?", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      HashSet<Scope.Var> hashSet0 = new HashSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, hashSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(91, 25, 45);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // ASSIGN_RSH 25 : com.google.javascript.rhino.jstype.NumberType@0000000044 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(93);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeInference", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = Node.newString(94, "TightenTypes pass appears to be stuck in an infinite loop.");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(95, "`*KL8W\"|()Aa^Rj%I", 3034, 3034);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope((Node) null);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(117, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(96, "TightenTypes pass appears to be stuck in an infinite loop.");
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node1, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(97);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      Node node1 = Node.newString(99, "", 83, 12);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // COLON  83 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", (-1598), 100);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      node0.setType(102);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(1249, "km<o+x", 54, 91);
      Node node1 = new Node(103, node0, node0, node0, 94, 54);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DEC 94 : com.google.javascript.rhino.jstype.NumberType@0000000041 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test68()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("A function type with the template type as the type of this must be a parameter type", 85, 1872);
      Node node1 = new Node(104, node0, node0, node0, 4095, 2);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test69()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test70()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("3wvmy", 127, 111);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, treeSet0);
      node0.setType(107);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test71()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
      Node node1 = new Node(108, node0, node0, node0, 950, 38);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // IF 950 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test72()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(109, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test73()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, (-1600));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(110);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test(timeout = 4000)
  public void test74()  throws Throwable  {
      Node node0 = Node.newString(87, "com.googlecommoncollect.AbstractSetMultim}p");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(111);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test75()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      Node node1 = Node.newString(114, "\"T|*o9@Q", (-3590), (-2392));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // DO \"T|*o9@Q does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test76()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      node0.setType(115);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test77()  throws Throwable  {
      Node node0 = Node.newString("\"T|*o9@Q", 0, 0);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      PriorityQueue<Scope.Var> priorityQueue0 = new PriorityQueue<Scope.Var>(35);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, priorityQueue0);
      node0.setType(116);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test78()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(117, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test79()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(105, "com.googlecommoncollect.AbstractSetMultimap");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TightenTypes tightenTypes0 = new TightenTypes(compiler0);
      JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      node0.setType(118);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test80()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("", (-56), 4633);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      Node node1 = new Node(119, node0, node0, 0, 33);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // WITH 0 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test81()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = Node.newString(121, "~Eyi\".~BU");
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, linkedList0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // FINALLY ~Eyi\".~BU does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test82()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(122, "wc.MP^5nK.NR%o-");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // VOID wc.MP^5nK.NR%o- : com.google.javascript.rhino.jstype.VoidType@0000000045 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test83()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("}z/p#S^>.VZ", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(124);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertEquals(0, list0.size());
  }

  @Test(timeout = 4000)
  public void test84()  throws Throwable  {
      Logger logger0 = Logger.getLogger(":reur");
      LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
      Compiler compiler0 = new Compiler(loggerErrorManager0);
      Node node0 = compiler0.parseTestCode(":reur");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test85()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(126, "JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED");
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      FlowScope flowScope0 = typeInference0.flowThrough(node0, linkedFlowScope0);
      assertNotSame(flowScope0, linkedFlowScope0);
  }

  @Test(timeout = 4000)
  public void test86()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 2883);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node0.setType(127);
      LinkedFlowScope.FlowScopeJoinOp linkedFlowScope_FlowScopeJoinOp0 = new LinkedFlowScope.FlowScopeJoinOp();
      FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
      FlowScope flowScope1 = linkedFlowScope_FlowScopeJoinOp0.apply(flowScope0, flowScope0);
      List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope1);
      assertTrue(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test87()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("41etrn", (-19), (-19));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      Node node1 = new Node(129, node0, node0, 101, 6);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPR_VOID 101 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test88()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("prototype", 93, 93);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = new Node(130, node0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // EXPR_RESULT does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test89()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString((-600), "wc.MP^5nK.NR%o-", (-600), (-600));
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeSet0);
      Node node1 = Node.newString(38, "wc.MP^5nK.NR%o-");
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, flowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // NAME wc.MP^5nK.NR%o- does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test90()  throws Throwable  {
      Node node0 = Node.newString("kpGA3u4//Op", (-5299), (-5299));
      Node node1 = new Node(35, node0, node0, node0, 48, 136);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      TreeSet<Scope.Var> treeSet0 = new TreeSet<Scope.Var>();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, closureCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeSet0);
      FlowScope flowScope0 = typeInference0.createEntryLattice();
      FlowScope flowScope1 = typeInference0.flowThrough(node1, flowScope0);
      assertNotSame(flowScope1, flowScope0);
  }

  @Test(timeout = 4000)
  public void test91()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("com.google.common.collect.AbstractSetMultimap", 117, 117);
      Node node1 = new Node(101, node0, node0, node0, 126, 49);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, closureReverseAbstractInterpreter0, scope0, linkedList0);
      node0.setType((-3));
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // AND 126 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test92()  throws Throwable  {
      BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.TRUE;
      BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
      assertEquals(BooleanLiteralSet.TRUE, booleanLiteralSet1);
  }

  @Test(timeout = 4000)
  public void test93()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString(":return", 2883, 2883);
      Node node1 = new Node(117, node0, node0, 35, 13);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node1);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node1.setType(120);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CATCH 35 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }

  @Test(timeout = 4000)
  public void test94()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = new Node(2883);
      Node node1 = new Node(74, node0, node0, node0, 950, 1);
      ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0);
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
      Scope scope0 = typedScopeCreator0.createInitialScope(node0);
      LinkedList<Scope.Var> linkedList0 = new LinkedList<Scope.Var>();
      TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, (ReverseAbstractInterpreter) null, scope0, linkedList0);
      node1.setType(37);
      LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
      // Undeclared exception!
      try { 
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // CALL 950 does not exist in graph
         //
         verifyException("com.google.javascript.jscomp.graph.LinkedDirectedGraph", e);
      }
  }
}
