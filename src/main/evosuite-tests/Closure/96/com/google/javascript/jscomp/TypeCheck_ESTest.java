/*
 * This file was automatically generated by EvoSuite
 * Sat Nov 04 04:40:18 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.CheckLevel;
import com.google.javascript.jscomp.CheckRegExp;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.ClosureReverseAbstractInterpreter;
import com.google.javascript.jscomp.CodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerOptions;
import com.google.javascript.jscomp.ConvertToDottedProperties;
import com.google.javascript.jscomp.DefaultCodingConvention;
import com.google.javascript.jscomp.DefaultPassConfig;
import com.google.javascript.jscomp.FunctionNames;
import com.google.javascript.jscomp.GoogleCodingConvention;
import com.google.javascript.jscomp.MemoizedScopeCreator;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.ProcessClosurePrimitives;
import com.google.javascript.jscomp.RecordFunctionInformation;
import com.google.javascript.jscomp.RemoveConstantExpressions;
import com.google.javascript.jscomp.ReverseAbstractInterpreter;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypedScopeCreator;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import java.util.List;
import java.util.Stack;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeCheck_ESTest extends TypeCheck_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test000()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(35, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(7, Node.LOCAL_PROP);
  }

  @Test(timeout = 4000)
  public void test001()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("", "");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString("_FUNTON_MASKSVARIBL");
      Node node1 = new Node(90, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node1);
      assertEquals(14, Node.DEFAULT_PROP);
  }

  @Test(timeout = 4000)
  public void test002()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      Node node1 = new Node(269, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.processForTesting(node0, node0);
      // Undeclared exception!
      try { 
        typeCheck0.process(node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test003()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Node node1 = new Node(152, node0, node0, 4, 122);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.processForTesting((Node) null, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test004()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      Node node1 = new Node(269, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.processForTesting(node0, node0);
      // Undeclared exception!
      try { 
        typeCheck0.process(node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test005()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, defaultCodingConvention0);
      MemoizedScopeCreator memoizedScopeCreator0 = new MemoizedScopeCreator(typedScopeCreator0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, memoizedScopeCreator0, compilerOptions0.checkMethods, compilerOptions0.checkFunctions);
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test006()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNpTION_MSKS_VARIABLE", "msg.function.not.found");
      Node node1 = new Node(0, node0, node0, node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      CheckLevel checkLevel0 = CheckLevel.WARNING;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      Scope scope0 = typeCheck0.processForTesting(node0, node0);
      TypeCheck typeCheck1 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, checkLevel0, checkLevel0);
      // Undeclared exception!
      try { 
        typeCheck1.processForTesting(node1, node1);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test007()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      // Undeclared exception!
      try { 
        typeCheck0.processForTesting(node0, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test008()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(86, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(25, Node.ISNUMBER_PROP);
  }

  @Test(timeout = 4000)
  public void test009()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("V(otpgYD7{[ln9[", "V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(105, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        nodeTraversal0.traverseInnerNode(node1, node0, (Scope) null);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // BLOCK [sourcename: java.lang.String@0000000546] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test010()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckLevel checkLevel0 = CheckLevel.OFF;
      ProcessClosurePrimitives processClosurePrimitives0 = new ProcessClosurePrimitives(compiler0, checkLevel0, true);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, processClosurePrimitives0, (ScopeCreator) null);
      Node node0 = Node.newString(118, "implements");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, Node.TARGET_PROP);
  }

  @Test(timeout = 4000)
  public void test011()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      node0.addSuppression("o/qWIfl,^.'26,Axz");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(42, Node.IS_CONSTANT_NAME);
  }

  @Test(timeout = 4000)
  public void test012()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/Ifl,^.'6,Axz", "(nN?\"e9hO");
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
      Node node1 = Node.newNumber(0.0, 2088, 23);
      Node node2 = new Node(37, node1, node0, node0, 7, 25);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      typeCheck0.visit(nodeTraversal0, node2, node0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test013()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(4, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(33, Node.NAME_PROP);
  }

  @Test(timeout = 4000)
  public void test014()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("PncQc1<N$:");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(5, node0, node0, node0, 0, 4);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test015()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(6, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test016()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCION_MASPS_VARIABLE", "JSC_FUNCION_MASPS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(7, node0, node0, node0, 2, 23);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test017()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(8, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test018()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(9, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test019()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JC_FUTIONMASS_VARABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(11, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test020()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(12, node0, node0, node0, 1, 21);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(10, Node.VARS_PROP);
  }

  @Test(timeout = 4000)
  public void test021()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("", "");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(13, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, Node.LEFT);
  }

  @Test(timeout = 4000)
  public void test022()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" E7#8S}ax\\");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(14, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(40, Node.BRACELESS_TYPE);
  }

  @Test(timeout = 4000)
  public void test023()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("I0iTHyWv]VMs-4\"y");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(15, "bad left operand to bitwise operator");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test024()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCT>Ow_McSKS_VARIABLE", "JSC_FUNCT>Ow_McSKS_VARIABLE");
      Node node1 = new Node(1, node0, node0, (-1037), 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.processForTesting(node0, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test025()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(17, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(46, Node.IS_DISPATCHER);
  }

  @Test(timeout = 4000)
  public void test026()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeCheck typeCheck0 = new TypeCheck(compiler0, reverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(18, node0, node0, node0, 29, 32);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test027()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(19, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test028()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(20, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test029()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Z#NR#,A4d}Fq`FNS;$");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      Node node1 = new Node(21, node0, node0, node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test030()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(22, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test031()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(23, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test032()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("V(otpgYD7{[ln9[", "V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(24, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test033()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNTON_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(25, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test034()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" E7#8S}ax\\");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(26, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(29, Node.VAR_ARGS_NAME);
  }

  @Test(timeout = 4000)
  public void test035()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" E7#8S}ax\\");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(27, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(10, Node.VARS_PROP);
  }

  @Test(timeout = 4000)
  public void test036()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(28, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, Node.SPECIALCALL_EVAL);
  }

  @Test(timeout = 4000)
  public void test037()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(29, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(41, Node.NO_SIDE_EFFECTS_CALL);
  }

  @Test(timeout = 4000)
  public void test038()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(31, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test039()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("g++1 #,E14W@$AA");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = new Node(32, node0, node0, node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(7, Node.LOCAL_PROP);
  }

  @Test(timeout = 4000)
  public void test040()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(34, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test041()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("mismatch of the {0} property type and the type of the property it overrides from superclass {1}\noriginal: {2}\noverride: {3}", "mismatch of the {0} property type and the type of the property it overrides from superclass {1}\noriginal: {2}\noverride: {3}");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(36, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(4, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test042()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode(" E7#8S}ax\\");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(41, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(46, Node.IS_DISPATCHER);
  }

  @Test(timeout = 4000)
  public void test043()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(42, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test044()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(43, "JSC_FUNCTION_MASKS_VARIABLE");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(4095, Node.MAX_COLUMN_NUMBER);
  }

  @Test(timeout = 4000)
  public void test045()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("JSC_FUNTON_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(44, 4095, 1);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(27, Node.SPECIALCALL_PROP);
  }

  @Test(timeout = 4000)
  public void test046()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(45, node0, node0, node0, 42, 13);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(100.0, double0, 0.01);
  }

  @Test(timeout = 4000)
  public void test047()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("V(otpgYD7{[ln9[", "fy?Jf'=j}+t-g");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(46, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, nodeTraversal0.getLineNumber());
  }

  @Test(timeout = 4000)
  public void test048()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(47, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals("", nodeTraversal0.getSourceName());
  }

  @Test(timeout = 4000)
  public void test049()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(48, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test050()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(49, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(4, Node.ENUM_PROP);
  }

  @Test(timeout = 4000)
  public void test051()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      Node node1 = new Node(50, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test052()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("Input variable map parse error: {0}", "Input variable map parse error: {0}");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString(51, "Input variable map parse error: {0}");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test053()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString(52, "?<(}4%qAI<Ew.\"lO");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test054()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("~SC_FUNCTION_MASKS_VARIABLE", "N|6");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(53, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test055()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(54, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test056()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "C!hb(~Oaav%W0+G=");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
      Node node1 = new Node(55, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test057()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("java/lang/Integer", "java/lang/Integer");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      Node node1 = new Node(56, node0);
      ConvertToDottedProperties convertToDottedProperties0 = new ConvertToDottedProperties(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, convertToDottedProperties0);
      CheckLevel checkLevel0 = CheckLevel.ERROR;
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0, checkLevel0, checkLevel0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test058()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(57, "?<(}4%qAI<Ew.\"lO");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test059()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(58, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test060()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      Node node1 = new Node(60, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test061()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/Ifl,^.'26,Axz", "(nN?\"pe9hO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(61, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test062()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
      Node node1 = new Node(62, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test063()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "C!hb(~Oaav%W0+G=");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString(63, "C!hb(~Oaav%W0+G=");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(45, Node.IS_NAMESPACE);
  }

  @Test(timeout = 4000)
  public void test064()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node1 = Node.newString(64, "implements");
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test065()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("Input variable map parse error: {0}", "Input variable map parse error: {0}");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString(65, "Input variable map parse error: {0}");
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test066()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("", "~`Wh~f&");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Node node1 = new Node(66, node0, node0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test067()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("", "");
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString(67, "");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test068()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback", "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback");
      Node node1 = new Node(68, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test069()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("I0iTHOWv]VLMs-4a\"Iy");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(69, "I0iTHOWv]VLMs-4a\"Iy");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test070()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("com.google.javascript.jscomp.DefaultPassConfig$53");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
      Node node1 = new Node(70, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test071()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCT>Ow_McSKS_VARIABLE", "JSC_FUNCT>Ow_McSKS_VARIABLE");
      Node node1 = new Node(71, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test072()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("~SC_FUNCTION_MASKS_VARIABLE", "N|6");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Node node0 = Node.newString(72, "N|6");
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test073()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      Node node1 = new Node(74, node0, node0, 20, 1);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test074()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("SC_FUNTON_MASKS_VARIABL");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(76, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test075()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCTION_ASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(77, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(26, Node.DIRECTCALL_PROP);
  }

  @Test(timeout = 4000)
  public void test076()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_sARIABLE", "JSC_FUNCTION_MASKS_sARIABLE");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(78, "JSC_FUNCTION_MASKS_sARIABLE");
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test077()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = Node.newString("implements");
      Node node1 = compiler0.parseTestCode("implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention)compiler0.defaultCodingConvention;
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node2 = new Node(79, node0, node1, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node2, node2);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test078()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(80, node0, node0, node0, 2, 1);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test079()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(81, node0, node0, node0, 9, 90);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test080()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("~SC_FUNCTION_MASKS_VARIABLE", "d>C0efN/)");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      Node node1 = Node.newString(82, "");
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test081()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("b\"f?;az", "(nN?\"pe9hO");
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Stack<JSType> stack0 = new Stack<JSType>();
      Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) stack0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test082()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("I0iTHOWv]VLMs-4a\"Iy");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(84, "I0iTHOWv]VLMs-4a\"Iy");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test083()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(87, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test084()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
      Node node1 = new Node(88, node0, node0, node0, 8, 28);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test085()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("|VT(otpgYD7{[ln9[", "|VT(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(89, node0, node0, node0, 2, 1);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test086()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("", "");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(90, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test087()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(91, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test088()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/Ifl,^.'26,Axz", "o/Ifl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(92, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test089()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(93, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, (Node) null);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test090()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
      Node node1 = new Node(94, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test091()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      Node node1 = new Node(95, node0, node0, node0, node0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test092()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(96, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test093()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(97, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test094()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/Ifl,^.'26,Axz", "o/Ifl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(98, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test095()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(99, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test096()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("Input variable map parse error: {0}", "Input variable map parse error: {0}");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString(100, "Input variable map parse error: {0}");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test097()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JC_FUNTIONMASS_VARABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(101, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test098()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.a'26,Axz", "o/qWIfl,^.a'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(102, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(13, Node.CASES_PROP);
  }

  @Test(timeout = 4000)
  public void test099()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(103, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, Node.RIGHT);
  }

  @Test(timeout = 4000)
  public void test100()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("V(otpgYD7{[ln9[", "V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(105, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // BLOCK [sourcename: java.lang.String@0000000546] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test101()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(106, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test102()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("$b0", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(107, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test103()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(108, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(34, Node.PARENTHESIZED_PROP);
  }

  @Test(timeout = 4000)
  public void test104()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(109, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test105()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("I0iTHyWv]VMs-4\"y");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(110, "I0iTHyWv]VMs-4\"y");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node0.isOptionalArg());
  }

  @Test(timeout = 4000)
  public void test106()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("ha?", "ha?");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(111, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test107()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(112, "");
      typeCheck0.visit((NodeTraversal) null, node1, node0);
      assertFalse(node1.isQuotedString());
  }

  @Test(timeout = 4000)
  public void test108()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("NaN", "NaN");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(113, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals((-3), Node.LOCAL_BLOCK_PROP);
  }

  @Test(timeout = 4000)
  public void test109()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("I0iTHyWv]VMs-4a\"y");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString(114, "m");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals("", nodeTraversal0.getSourceName());
  }

  @Test(timeout = 4000)
  public void test110()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JC_FUTIONMASS_VARABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(115, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertFalse(node1.hasMoreThanOneChild());
  }

  @Test(timeout = 4000)
  public void test111()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("I0iTHOWv]VLMs-4a\"Iy");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(116, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(116, node1.getType());
  }

  @Test(timeout = 4000)
  public void test112()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(117, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node1.isNoSideEffectsCall());
  }

  @Test(timeout = 4000)
  public void test113()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(119, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, nodeTraversal0.getLineNumber());
  }

  @Test(timeout = 4000)
  public void test114()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(120, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(12, Node.COLUMN_BITS);
  }

  @Test(timeout = 4000)
  public void test115()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASPS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(121, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test116()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("I0iTHyWv]VMs-4a\"y");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(122, "I0iTHyWv]VMs-4a\"y");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, Node.BOTH);
  }

  @Test(timeout = 4000)
  public void test117()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("=`8#h|", "=`8#h|");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(123, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(4, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test118()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("=`8#h|", "=`8#h|");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(124, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertFalse(node0.isSyntheticBlock());
  }

  @Test(timeout = 4000)
  public void test119()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(126, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(12, Node.REGEXP_PROP);
  }

  @Test(timeout = 4000)
  public void test120()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(127, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test121()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("V(otpgYD7{[ln9[", "V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(128, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test122()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("@d QyEPqbq");
      Node node1 = new Node(129, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test123()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("'Z[vb(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(131, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test124()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(133, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test125()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNTON_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(134, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test126()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("|VT(otpgYD7{[ln9[", "|VT(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
      Node node1 = new Node(135, node0, node0, node0, 19, 2);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test127()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = (GoogleCodingConvention)compiler0.defaultCodingConvention;
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(136, node0, node0, node0);
      RemoveConstantExpressions.RemoveConstantRValuesCallback removeConstantExpressions_RemoveConstantRValuesCallback0 = new RemoveConstantExpressions.RemoveConstantRValuesCallback();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, removeConstantExpressions_RemoveConstantRValuesCallback0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test128()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASPS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(137, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test129()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("", "");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(138, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test130()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("JSC_FUNCTION_ASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      CodingConvention codingConvention0 = compiler0.getCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(codingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      Node node0 = Node.newString(139, "JSC_FUNCTION_ASKS_VARIABLE");
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test131()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("|VT(otpgYD7{[ln9[", "|VT(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(140, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test132()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("ha?", "ha?");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(141, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test133()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("o/qWIfl,^.'26,Axz", "o/qWIfl,^.'26,Axz");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(142, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test134()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("mismatch of the {0} property type and the type of the property it overrides from interface {1}\noriginal: {2}\noverride: {3}");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = new Node(143);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(4, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test135()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = new Node(144, node0, node0, node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test136()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = new Node(145, node0, node0, node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(1, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test137()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
      Node node1 = Node.newString(146, "implements");
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(2, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test138()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("|VT(otpgYD7{[ln9[", "|VT(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(147, node0, node0);
      FunctionNames functionNames0 = new FunctionNames(compiler0);
      RecordFunctionInformation recordFunctionInformation0 = new RecordFunctionInformation(compiler0, functionNames0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, recordFunctionInformation0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(2, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test139()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      Node node1 = new Node(148, node0, node0, node0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test140()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(149, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(3, compiler0.getErrorCount());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test141()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCTION_MASKS_VARIABLE", "JSC_FUNCTION_MASKS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
      TypeCheck typeCheck0 = new TypeCheck(compiler0, reverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(150, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertTrue(compiler0.hasErrors());
      assertEquals(1, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test142()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("@d QyEPqbq");
      Node node1 = new Node(151, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // 151
         //
         verifyException("com.google.javascript.rhino.Token", e);
      }
  }

  @Test(timeout = 4000)
  public void test143()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("I0iTHyWv]VMs-4a\"y");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node0 = Node.newString(152, "LD.2]?9)o# #,!~Q;E");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node0, node0);
      assertEquals(41, Node.NO_SIDE_EFFECTS_CALL);
  }

  @Test(timeout = 4000)
  public void test144()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("implements", "implements");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(153);
      typeCheck0.visit((NodeTraversal) null, node1, node0);
      assertEquals(48, Node.DIRECT_EVAL);
  }

  @Test(timeout = 4000)
  public void test145()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("", "");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(0, node0, node0, node0, 11, 42);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(1, compiler0.getErrorCount());
      assertTrue(compiler0.hasErrors());
  }

  @Test(timeout = 4000)
  public void test146()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("b\"f?;az", "(nN?\"pe9hO");
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Stack<JSType> stack0 = new Stack<JSType>();
      Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) stack0);
      Node node2 = new Node(105, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node2);
      assertFalse(node1.isVarArgs());
  }

  @Test(timeout = 4000)
  public void test147()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("hSC_FU[CTI)N_MASKSVA5IALE");
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, (JSTypeRegistry) null);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, (JSTypeRegistry) null);
      Node node1 = Node.newString(100, "hSC_FU[CTI)N_MASKSVA5IALE");
      Node node2 = new Node(33, node0, node1);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      CompilerOptions compilerOptions0 = new CompilerOptions();
      DefaultPassConfig defaultPassConfig0 = new DefaultPassConfig(compilerOptions0);
      TypeCheck typeCheck1 = defaultPassConfig0.makeTypeCheck(compiler0);
      typeCheck1.visit(nodeTraversal0, node2, node1);
      typeCheck1.visit(nodeTraversal0, node2, node1);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test148()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("V(otpgYD7{[ln9[", "V(otpgYD7{[ln9[");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(105, node0, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node1, node1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test149()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(120, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test150()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JSC_FUNCION_MASKSVARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      Vector<JSType> vector0 = new Vector<JSType>(49);
      Node node1 = jSTypeRegistry0.createParametersWithVarArgs((List<JSType>) vector0);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test151()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("@d QyEPqbq");
      CompilerOptions compilerOptions0 = compiler0.getOptions();
      Node node1 = new Node(118, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, compilerOptions0.checkRequires, compilerOptions0.checkMissingGetCssNameLevel);
      boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test152()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("mismatch of the {0} property type and the type of the property it overrides from interface {1}\noriginal: {2}\noverride: {3}");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString("");
      Node node2 = new Node(33, node0, node1);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node2, node0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeCheck", e);
      }
  }

  @Test(timeout = 4000)
  public void test153()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("Id0iTnZWVLMh-4a\">(", "Id0iTnZWVLMh-4a\">(");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(118, node0, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      // Undeclared exception!
      try { 
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // BLOCK [sourcename: java.lang.String@0000000551] is not a string node
         //
         verifyException("com.google.javascript.rhino.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void test154()  throws Throwable  {
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("JSC_FUNCION_MASPS_VARIABLE", "JSC_FUNCION_MASPS_VARIABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(37, node0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node1);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test155()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" ms ", " ms ");
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = Node.newString(12, "TightenTypes pass appears to be stuck in an infinite loop.");
      Node node2 = new Node(30, node0, node1);
      typeCheck0.visit((NodeTraversal) null, node2, node2);
      assertEquals(29, Node.VAR_ARGS_NAME);
  }

  @Test(timeout = 4000)
  public void test156()  throws Throwable  {
      GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("JC_FUTIONMASS_VARABLE");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      Node node1 = new Node(10, node0, node0, node0);
      node1.addSuppression((String) null);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
      typeCheck0.visit(nodeTraversal0, node1, node0);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(compiler0.hasErrors());
      assertEquals(0, compiler0.getErrorCount());
  }

  @Test(timeout = 4000)
  public void test157()  throws Throwable  {
      DefaultCodingConvention defaultCodingConvention0 = new DefaultCodingConvention();
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("?<(}4%qAI<Ew.\"lO", "?<(}4%qAI<Ew.\"lO");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(defaultCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      double double0 = typeCheck0.getTypedPercent();
      assertEquals(0.0, double0, 0.01);
  }
}
