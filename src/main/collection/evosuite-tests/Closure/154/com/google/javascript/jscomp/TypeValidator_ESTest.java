/*
 * This file was automatically generated by EvoSuite
 * Sun Nov 19 23:13:59 GMT 2023
 */

package com.google.javascript.jscomp;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.javascript.jscomp.ClosureCodingConvention;
import com.google.javascript.jscomp.Compiler;
import com.google.javascript.jscomp.CompilerInput;
import com.google.javascript.jscomp.Denormalize;
import com.google.javascript.jscomp.FlowSensitiveInlineVariables;
import com.google.javascript.jscomp.GatherRawExports;
import com.google.javascript.jscomp.GroupVariableDeclarations;
import com.google.javascript.jscomp.JSSourceFile;
import com.google.javascript.jscomp.NameReferenceGraph;
import com.google.javascript.jscomp.NameReferenceGraphConstruction;
import com.google.javascript.jscomp.NodeTraversal;
import com.google.javascript.jscomp.ReferenceCollectingCallback;
import com.google.javascript.jscomp.Scope;
import com.google.javascript.jscomp.ScopeCreator;
import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;
import com.google.javascript.jscomp.SyntacticScopeCreator;
import com.google.javascript.jscomp.TypeCheck;
import com.google.javascript.jscomp.TypeValidator;
import com.google.javascript.jscomp.UnfoldCompoundAssignments;
import com.google.javascript.jscomp.UnreachableCodeElimination;
import com.google.javascript.rhino.Node;
import com.google.javascript.rhino.SimpleErrorReporter;
import com.google.javascript.rhino.jstype.EnumElementType;
import com.google.javascript.rhino.jstype.EnumType;
import com.google.javascript.rhino.jstype.FunctionType;
import com.google.javascript.rhino.jstype.InstanceObjectType;
import com.google.javascript.rhino.jstype.JSType;
import com.google.javascript.rhino.jstype.JSTypeNative;
import com.google.javascript.rhino.jstype.JSTypeRegistry;
import com.google.javascript.rhino.jstype.NoType;
import com.google.javascript.rhino.jstype.NullType;
import com.google.javascript.rhino.jstype.ObjectType;
import com.google.javascript.rhino.jstype.UnknownType;
import java.nio.charset.Charset;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class TypeValidator_ESTest extends TypeValidator_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" nl \"rrays*Or ob1ecFsca ce acce(sed", " nl \"rrays*Or ob1ecFsca ce acce(sed");
      UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "Named type with empty name component", jSType0);
      assertEquals(1, compiler0.getWarningCount());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("`JXDCZ[.t:M[!2?B8X");
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      Iterable<TypeValidator.TypeMismatch> iterable0 = typeValidator0.getMismatches();
      assertNotNull(iterable0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("!");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
      String string0 = typeValidator_TypeMismatch0.toString();
      assertEquals("(undefined, undefined)", string0);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, "Not declared as a type name");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("!");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, "Named type with empty name component");
      assertEquals(1, compiler0.getWarningCount());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectActualObject((NodeTraversal) null, node0, noType0, "Unknown class name");
      assertFalse(noType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      NullType nullType0 = (NullType)jSTypeRegistry0.createDefaultObjectUnion(noType0);
      typeValidator0.expectActualObject(nodeTraversal0, node0, nullType0, "t'ptp$Gy");
      assertEquals(1, compiler0.getWarningCount());
      assertFalse(noType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
      typeValidator0.expectAnyObject(nodeTraversal0, node0, functionType0, "Named type with empty name component");
      assertTrue(functionType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
      typeValidator0.expectAnyObject(nodeTraversal0, node0, noType0, "Named type with empty name component");
      assertTrue(noType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("~,,[QIF.L&A");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, syntacticScopeCreator0);
      JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
      typeValidator0.expectAnyObject(nodeTraversal0, node0, jSType1, "Named type with empty name component");
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
      InstanceObjectType instanceObjectType0 = (InstanceObjectType)jSTypeRegistry0.getNativeType(jSTypeNative0);
      GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
      typeValidator0.expectIndexMatch(nodeTraversal0, node0, instanceObjectType0, noType0);
      assertEquals(0, compiler0.getWarningCount());
      assertFalse(noType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      // Undeclared exception!
      try { 
        typeValidator0.expectIndexMatch((NodeTraversal) null, node0, jSType0, jSType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0, (ScopeCreator) null);
      typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, "^#");
      assertEquals(0, Node.LABEL_ID_PROP);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, "Not declared as a type name");
      assertEquals(1, compiler0.getWarningCount());
      assertTrue(functionType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("!");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, "Not declared as a constructor");
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
      SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
      TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
      typeValidator0.expectStringOrNumber(nodeTraversal0, node0, jSType0, "Not declared as a type name");
      assertEquals(29, Node.VAR_ARGS_NAME);
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSType jSType0 = jSTypeRegistry0.createNamedType("Not declared as a constructor", "Unknown class name", 49, 1);
      typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, functionType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      compiler0.parseTestCode("Unknown class name");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", jSType0);
      typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, enumType0, "Not declared as a type name");
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined((NodeTraversal) null, node0, jSType0, "Named type with empty name component", jSType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Attempt to remove() an extern definition.");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.CHECKED_UNKNOWN_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "/J_G4NIDGVp#", jSType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" nl \"rrays*Or ob1ecFsca ce acce(sed", " nl \"rrays*Or ob1ecFsca ce acce(sed");
      UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, functionType0, "Unknown class name", functionType0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
      boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, "Not declared as a constructor", (JSType) null);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
      InstanceObjectType instanceObjectType0 = (InstanceObjectType)jSTypeRegistry0.getNativeType(jSTypeNative0);
      GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
      typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, instanceObjectType0, noType0);
      assertTrue(noType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseSyntheticCode("Not declared as a constructor", "Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeNative jSTypeNative1 = JSTypeNative.TOP_LEVEL_PROTOTYPE;
      ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative1);
      typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, objectType0, jSType0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
      JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      // Undeclared exception!
      try { 
        typeValidator0.expectSwitchMatchesCase((NodeTraversal) null, node0, objectType0, jSType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, jSType0);
      assertTrue(functionType0.hasCachedValues());
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Attempt to remove() an extern definition.");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf((NodeTraversal) null, node0, jSType0, jSType0, node0, "Not declared as a constructor");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", jSType0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, enumType0, (Node) null, "Unknown class name");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("Not declared as a constructor", functionType0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      // Undeclared exception!
      try { 
        typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, functionType0, enumType0, (Node) null, "Unknown class name");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("Named type with empty name component", jSType0);
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      EnumType enumType1 = jSTypeRegistry0.createEnumType("Not declared as a constructor", enumType0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, "Named type with empty name component");
      assertFalse(boolean0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
      boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, functionType0, "Unknown class name");
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, functionType0, "Named type with empty name component");
      assertTrue(functionType0.hasCachedValues());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, noType0, "Not declared as a type name");
      assertTrue(noType0.hasCachedValues());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
      typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, jSType0, node0, 6);
      assertFalse(node0.isQuotedString());
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      // Undeclared exception!
      try { 
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, functionType0, node0, 1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectCanOverride((NodeTraversal) null, node0, jSType0, jSType0, "Not declared as a type name", jSType0);
      assertEquals(43, Node.IS_OPTIONAL_PARAM);
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" nly arrays*Or ob1ecFscan ce acce(sed", " nly arrays*Or ob1ecFscan ce acce(sed");
      UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      JSType[] jSTypeArray0 = new JSType[7];
      jSTypeArray0[6] = (JSType) functionType0;
      FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) null, jSTypeArray0);
      ObjectType objectType0 = jSTypeRegistry0.createObjectType((ObjectType) functionType1);
      typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, objectType0);
      assertEquals(1, Node.DECR_FLAG);
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = new TypeValidator(compiler0);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
      // Undeclared exception!
      try { 
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" nly \"rrays*Or ob1ecFscan ce acce(sed", " nly \"rrays*Or ob1ecFscan ce acce(sed");
      UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" nly \"rrays*Or ob1ecFscan ce acce(sed", " nly \"rrays*Or ob1ecFscan ce acce(sed");
      UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      typeValidator0.setShouldReport(false);
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, jSType0);
      assertFalse(functionType0.hasCachedValues());
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      Denormalize denormalize0 = new Denormalize(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, noType0);
      assertTrue(noType0.hasCachedValues());
      assertFalse(functionType0.hasCachedValues());
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      Scope scope0 = new Scope(node0, noType0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Scope.Var scope_Var0 = scope0.declare("kd0R7KXL)JtA|os=\"f", node0, noType0, (CompilerInput) null, true);
      // Undeclared exception!
      try { 
        typeValidator0.expectUndeclaredVariable("<k;vjYdTDAt^gO", node0, node0, scope_Var0, "kd0R7KXL)JtA|os=\"f", noType0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node0 = new Node(33);
      // Undeclared exception!
      try { 
        typeValidator0.expectUndeclaredVariable("Unknown class name", node0, node0, (Scope.Var) null, "Not declared as a type name", jSType0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.javascript.jscomp.TypeValidator", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("SBx' ", "SBx' ");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Scope scope0 = new Scope(node0, compiler0);
      Scope.Var scope_Var0 = scope0.declare("#I-", node0, (JSType) null, (CompilerInput) null);
      typeValidator0.expectUndeclaredVariable("SBx' ", node0, node0, scope_Var0, "JSC_DUP_VAR_DECLARATION", (JSType) null);
      assertEquals(40, Node.BRACELESS_TYPE);
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode(" nly \"rrays*Or ob1ecFscan ce acce(sed", " nly \"rrays*Or ob1ecFscan ce acce(sed");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      Scope scope0 = new Scope(node0, compiler0);
      EnumType enumType0 = jSTypeRegistry0.createEnumType("Unknown class name", functionType0);
      EnumElementType enumElementType0 = enumType0.getElementsType();
      JSType jSType0 = enumElementType0.getPropertyType("Not declared as a type name");
      Charset charset0 = Charset.defaultCharset();
      JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("S63MumJVF_q[` sQ\"f", charset0);
      CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
      Scope.Var scope_Var0 = scope0.declare("EP", node0, jSType0, compilerInput0, false);
      typeValidator0.expectUndeclaredVariable("", node0, node0, scope_Var0, "S63MumJVF_q[` sQ\"f", enumElementType0);
      assertEquals(6, Node.TEMP_PROP);
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
      CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
      Scope scope0 = new Scope(node0, noType0);
      Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, false);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectUndeclaredVariable("Named type with empty name component", node0, node0, scope_Var0, "Not declared as a type name", (JSType) null);
      assertEquals(40, Node.BRACELESS_TYPE);
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      Scope scope0 = new Scope(node0, noType0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Scope.Var scope_Var0 = scope0.declare("_nD1HOfPD", node0, noType0, (CompilerInput) null, true);
      NameReferenceGraphConstruction nameReferenceGraphConstruction0 = new NameReferenceGraphConstruction(compiler0);
      NameReferenceGraph nameReferenceGraph0 = nameReferenceGraphConstruction0.getNameReferenceGraph();
      NameReferenceGraph.Name nameReferenceGraph_Name0 = nameReferenceGraph0.WINDOW;
      UnknownType unknownType0 = (UnknownType)nameReferenceGraph_Name0.getType();
      typeValidator0.expectUndeclaredVariable("", node0, node0, scope_Var0, "", unknownType0);
      assertFalse(unknownType0.isConstructor());
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      Scope scope0 = new Scope(node0, noType0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node1 = new Node(118, node0, node0, node0, 7, 4095);
      Scope.Var scope_Var0 = scope0.declare("kd0R7KXL)JtA|os=\"f", node0, noType0, (CompilerInput) null, true);
      typeValidator0.expectUndeclaredVariable("<k;vjYdTDAt^gO", node1, node1, scope_Var0, "kd0R7KXL)JtA|os=\"f", noType0);
      typeValidator0.getReadableJSTypeName(node0, true);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a type name");
      Scope scope0 = new Scope(node0, noType0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node1 = new Node(118, node0, node0, node0, 7, 4095);
      Scope.Var scope_Var0 = scope0.declare("kd0R7KXL)JtA|os=\"f", node0, noType0, (CompilerInput) null, true);
      typeValidator0.expectUndeclaredVariable("kd0R7KXL)JtA|os=\"f", node0, node1, scope_Var0, "*[[2?!+4~yQ", noType0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
      CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, true);
      Scope scope0 = new Scope(node0, noType0);
      Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, true);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node1 = new Node(1, node0, 4095, 10);
      typeValidator0.expectUndeclaredVariable("Not declared as a constructor", node0, node1, scope_Var0, "Not declared as a constructor", noType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
      CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
      Scope scope0 = new Scope(node0, noType0);
      Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, false);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node1 = new Node(130, node0, node0, node0, 34, 44);
      typeValidator0.expectUndeclaredVariable("Not declared as a constructor", node1, node1, scope_Var0, "Not declared as a constructor", noType0);
      assertEquals(1, Node.DECR_FLAG);
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Unknown class name");
      JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("Named type with empty name component");
      CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
      Scope scope0 = new Scope(node0, noType0);
      Scope.Var scope_Var0 = scope0.declare("Named type with empty name component", node0, noType0, compilerInput0, false);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node1 = new Node(130, node0, node0, node0, 34, 44);
      Vector<JSType> vector0 = new Vector<JSType>();
      FunctionType functionType0 = (FunctionType)jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) noType0, (JSType) noType0, (List<JSType>) vector0);
      typeValidator0.expectUndeclaredVariable("kI`}oOzsS", node0, node1, scope_Var0, "", functionType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
      NoType noType0 = (NoType)jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectAllInterfaceProperties((NodeTraversal) null, node0, noType0);
      assertEquals(4, Node.DESCENDANTS_FLAG);
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseSyntheticCode("actual parameter %d of %s does not match formal parameter", "actual parameter %d of %s does not match formal parameter");
      ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
      ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.setShouldReport(false);
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
      typeValidator0.expectIndexMatch(nodeTraversal0, node0, functionType0, functionType0);
      assertEquals(0, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Denormalize denormalize0 = new Denormalize(compiler0);
      Node node0 = compiler0.parseTestCode("Named type with empty name component");
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectCanCast(nodeTraversal0, node0, jSType0, functionType0);
      assertTrue(functionType0.hasCachedValues());
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("Not declared as a constructor");
      JSTypeNative jSTypeNative1 = JSTypeNative.ARRAY_FUNCTION_TYPE;
      FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative1);
      GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
      NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      typeValidator0.expectCanOverride(nodeTraversal0, node0, jSType0, functionType0, "Unknown class name", jSType0);
      assertEquals(1, compiler0.getWarningCount());
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseTestCode("Unknown class name");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node0 = new Node(33);
      Node node1 = Node.newString(45, "Unknown class name");
      node0.addChildrenToFront(node1);
      String string0 = typeValidator0.getReadableJSTypeName(node0, true);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Node node0 = compiler0.parseTestCode("~,,[QIF.L&A");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      String string0 = typeValidator0.getReadableJSTypeName(node0, false);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      compiler0.parseSyntheticCode("actual parameter %d of %s does not match formal parameter", "actual parameter %d of %s does not match formal parameter");
      TypeValidator typeValidator0 = compiler0.getTypeValidator();
      Node node0 = new Node(42);
      String string0 = typeValidator0.getReadableJSTypeName(node0, true);
      assertEquals("this", string0);
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      Compiler compiler0 = new Compiler();
      Denormalize denormalize0 = new Denormalize(compiler0);
      compiler0.parseTestCode("!");
      JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
      JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
      boolean boolean0 = typeValidator_TypeMismatch0.equals(denormalize0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
      boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(functionType0, jSType0);
      boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
      assertFalse(boolean0);
      assertFalse(typeValidator_TypeMismatch1.equals((Object)typeValidator_TypeMismatch0));
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
      JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
      JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
      JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch0 = new TypeValidator.TypeMismatch(jSType0, jSType0);
      LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
      FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
      TypeValidator.TypeMismatch typeValidator_TypeMismatch1 = new TypeValidator.TypeMismatch(jSType0, functionType0);
      boolean boolean0 = typeValidator_TypeMismatch0.equals(typeValidator_TypeMismatch1);
      assertFalse(boolean0);
      assertFalse(typeValidator_TypeMismatch1.equals((Object)typeValidator_TypeMismatch0));
  }
}
